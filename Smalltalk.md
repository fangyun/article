# Smalltalk 的早期历史

*Alan C. Kay*
*苹果电脑*
*kay2@apple.com.Internet#*

允许免费复制本材料的全部或部分内容，但前提是复制品不得用于直接商业用途，且必须保留 ACM 版权声明、出版物名称及出版日期，并注明复制已获得美国计算机协会 (ACM) 的许可。除此以外，任何复制或再版行为均需付费和/或获得特定许可。HOPL
-II/4/93/MA, USA © 1993 ACM 0-89791-571-2/93/0004/0069...$1.50

## 抽象的

大多数想法都源于先前的想法。六十年代，尤其是在ARPA社区，通过交互式分时计算机、图形屏幕和指针设备，催生了大量关于“人机共生”的概念。人们发明了先进的计算机语言来模拟复杂的系统，例如炼油厂和半智能行为。随后出现的现代个人计算、重叠窗口界面和面向对象设计的范式转变，源于人们将六十年代的工作视为超越“旧事物的升级版”。也就是说，它不仅仅是改进大型机计算、方便终端用户调用功能或使数据结构更加抽象的方法。相反，计算量/资金/交易量的指数级增长前景要求人们将六十年代视为“*几乎*全新的事物”，并探寻真正的“新事物”究竟是什么。例如，人们可以使用手持式“Dynabook”进行计算，而这在共享大型机上是不可能实现的；数百万潜在用户意味着用户界面必须成为类似蒙特梭利和布鲁纳的学习环境；而对广泛范围、降低复杂性和最终用户素养的需求，则要求摒弃数据和控制结构，转而采用更像生物学的方案，即受保护的通用细胞仅通过可以模拟任何所需行为的消息进行交互。

早期的Smalltalk是这些新观点的首次完整实现，这些观点源于硬件、语言和用户界面设计领域的诸多先驱。它之所以成为新计算的典范，部分原因在于我们当时确实在尝试一种信念结构的质变——一种与印刷术发明精神相呼应的库恩式新范式——因此我们采取了极其激进的立场，几乎是迫使这些新风格的诞生。

## 目录

- 引言[2](#p2)
- 一、1960-66 年——面向对象编程的早期发展及其他六十年代的形成性思想[4](#p4)
  - B220 文件系统
  - 草图板和开始
- 二、1967-69 年——FLEX 机器，一款基于面向对象编程的个人电脑[6](#p6)
  - 道格·恩格尔巴特和NLS
  - 等离子面板、GRAIL、LOGO、Dynabook
- 三、1970-72 年——施乐帕克研究中心[12](#p12)
  - KiddiKomp
  - 迷你电脑
  - Smalltalk-71
  - 重叠窗口
  - 字体编辑、绘画、动画、音乐
  - 字节码
  - 标志性节目
- 四、1972-76 年——施乐帕克研究中心：第一个真正的 Smalltalk (-72) [17](#p17)
  - 两大赌注：Smalltalk 的诞生和过渡期 Dynabook
  - Smalltalk 72 原则
  - Smalltalk 用户界面
  - Smalltalk应用程序和系统的开发
  - Smalltalk 的发展历程：ST-74、Ooze 存储管理
  - [闲聊和孩子](#smalltalkAndChildren)
- V. 1976-80—第一个现代Smalltalk（-76）[29](#p29)
  - “我们来烧录光盘吧。”
  - 笔记员
  - Smalltalk-76
  - 遗产
  - 施乐公司又出问题了
  - ThingLab
  - 苹果演示
- VI. 1980-83 年——Smalltalk (-80) 的发布版本[38](#p38)
  - 转变
  - [结尾](#coda)
- 正文中引用的参考文献[41](#p41)
- 附录一：KiddiKomp备忘录[45](#p45)
- 附录二：Smalltalk-72 解释器设计[47](#p47)
- 附录三：致谢[50](#p50)
- 附录四：事件驱动循环示例[53](#p53)
- 附录五：Smalltalk-76 内部结构[54](#p54)

——致 Dan Ingalls、Adele Goldberg 以及 Xerox PARC LRG 团队的其他成员

——致戴夫·埃文斯、鲍勃·巴顿、马文·明斯基和西摩·帕珀特

——献给 SKETCHPAD、JOSS、LISP 和 SIMULA，六十年代的四大编程理念

## 介绍

我正在三万五千英尺的高空飞机上写这篇引言。我的腿上放着一台五磅重的笔记本电脑——1992 年的“过渡型 Dynabook”——到年底它的售价不到 700 美元。它拥有平坦、清晰的高分辨率位图屏幕，支持窗口重叠、图标显示、指针设备，以及相当可观的存储空间和计算能力，其最佳软件是面向对象的。它内置了先进的网络功能，并且已经有了无线网络选项。Smalltalk 语言可以在这套系统上运行，也是我目前从事儿童工作的主要系统之一。在某些方面，它比 Dynabook 更胜一筹（从数量上看），但在某些方面，它还不够完善（从质量上看）。总而言之，它基本符合六十年代末人们的设想。

Smalltalk是ARPA（美国高级研究计划署）以及后来的施乐帕克研究中心（Xerox PARC）所倡导的更宏大的*个人计算计划的一部分。*由于每个阶段都有众多研究界人士参与，因此很难准确地分配每个人的贡献。正如鲍勃·巴顿喜欢引用歌德的话，我们应该“分享发现的喜悦，而不是徒劳地试图争夺优先权”。

我将尝试阐明大多数影响的来源，以及它们如何在新的个人计算隐喻所形成的磁场中发生转变。正是先驱者们的态度和伟大的思想促成了 Smalltalk 的诞生。当时我最敬佩的许多人——例如 Ivan Sutherland、Marvin Minsky、Seymour Papert、Gordon Moore、Bob Barton、Dave Evans、Butler Lampson、Jerome Bruner 等等——似乎都有一种敏锐的意识：他们的创造虽然相对而言非常出色，但距离必须跨越的绝对门槛还很远。心胸狭隘的人试图创立宗教，而伟大的人只是想要找到更好的登山路线。正如牛顿所说，他站在巨人的肩膀上看得更远，而计算机科学家们却常常互相掣肘。近视仍然是一个问题，尽管有巨人的肩膀可以依靠——“外在的眼光”比内在的眼光更好——但可以通过使用对美学和评论高度敏感的镜片眼镜来最大限度地减少近视的影响。

编程语言可以从多个角度进行分类：命令式、应用式、逻辑式、问题导向式等等。但它们似乎都属于“特性聚合”或“风格结晶”的范畴。COBOL、PL/1、Ada 等属于第一类；LISP、APL 和 Smalltalk 则属于第二类。特性聚合型语言似乎都是由委员会发起，而风格结晶型语言则是由个人主导，这或许并非偶然。

Smalltalk 的设计——以及它的存在——源于这样一个洞见：我们所能描述的一切都可以用一种行为构建模块的递归组合来表示，这种构建模块将自身的状态和过程组合隐藏起来，并且只能通过消息交换来处理。从哲学角度来看，Smalltalk 的对象与莱布尼茨的单子以及 20 世纪物理学和生物学的概念有很多共同之处。它创建对象的方式颇具柏拉图式的风格，因为其中一些对象充当了概念的理想化——*理念*——而从中可以创造出*各种显现*。理念本身就是显现（理念-理念的显现），而理念-理念又是*一种*显现-理念——后者本身也是一种显现-理念，因此该系统完全是自描述的——这在柏拉图看来会是一个极其巧妙的玩笑。

从计算机角度来看，Smalltalk 是对计算机概念本身的一种递归。它不像其他编程语言那样将“计算机组件”分割成一个个弱化整体的子集（例如数据结构、过程和函数），而是将每个 Smalltalk 对象递归地映射到计算机的全部可能性上。因此，它的语义有点像成千上万台计算机通过高速网络连接在一起。具体表示的问题几乎可以无限期地推迟，因为我们主要关注的是计算机的运行是否正常，只有当结果出现偏差或响应速度过慢时，我们才会考虑具体的策略。

尽管 Smalltalk 的确拥有优秀的先例，但它真正的贡献在于提出了一种全新的设计范式——我称之为*面向对象*——旨在解决专业程序员面临的大型问题，同时也让新手用户能够轻松应对一些小问题。面向对象设计成功地从根本上提高了对日益复杂的动态系统和用户关系进行建模的效率，而这些系统和关系的构建正是由硅谷爆炸带来的。

“我们当时就知道他们是怎么想的。”
——理查德·哈明

“记忆和想象不过是同一事物的两种说法。”
——托马斯·霍布斯

在这段历史叙述中，我将力求忠实于汉明的要求，并借鉴霍布斯的观察。我之前尝试撰写关于Smalltalk的文章时遇到了一些困难，因为我的情感投入始终集中在个人计算作为人类影响力的放大器上——而非编程系统设计本身——而我们尚未实现这一目标。尽管我是Smalltalk的发起人和最初的设计者，但它始终更多地属于那些让它运转起来并最终发布的人，特别是Dan Ingalls和Adele Goldberg。LRG的每一位成员都以深刻而卓越的方式为这个项目做出了贡献，我真希望有足够的篇幅来充分介绍他们。但我相信我们都会同意，在Smalltalk的大部分开发过程中，Dan是核心人物。编程本质上是一门实践艺术，它构建的是真实的事物，因此必须存在一个真实的实现。事实上，如今许多（如果不是大多数）编程语言之所以被使用，并不是因为它们本身有什么真正的优点，而是因为它们存在于一台或多台机器上，能够自举等等。但丹不仅仅是一位伟大的实现者，随着 Smalltalk 进入实际应用领域，他也越来越成为一位设计者，不仅是语言的设计者，还有用户界面的设计者。

本文将着重探讨Smalltalk-72及其向现代形式Smalltalk-76过渡的历程。大多数思想都诞生于此，而面向对象编程（OOP）的许多早期阶段都鲜有文献记载，且几乎无法找到相关资料。

这段历史太过漫长，但我惊讶地发现，许多产生过影响的人和体系，要么只是寥寥几笔带过，要么根本无人提及。很遗憾，我无法详细提及鲍勃·巴尔泽、鲍勃·巴顿、丹尼·博布罗、史蒂夫·卡尔、韦斯·克拉克、芭芭拉·德意志、彼得·德意志、比尔·杜瓦尔、鲍勃·弗莱格尔、劳拉·古尔德、布鲁斯·霍恩、巴特勒·兰普森、戴夫·利德尔、威廉·纽曼、比尔·帕克斯顿、特里格夫·雷恩斯考格、戴夫·罗布森、道格·罗斯、保罗·罗夫纳、鲍勃·斯普劳尔、丹·斯温哈特、伯特·萨瑟兰、鲍勃·泰勒、沃伦·泰特尔曼、邦妮·坦南鲍姆、查克·萨克和约翰·沃诺克。更糟糕的是，我还遗漏了许多我厌恶其设计的体系，但它们却催生了许多有益的思想和态度。换句话说，“历史”不应该被认真对待，而应该被视为演员离开舞台很久之后所做的“无力的姿态”。

感谢众多审稿人耐心审阅并提出宝贵意见。特别感谢Mike Mahoney，他温和的指导让我采纳了他的建议，这些建议极大地改进了这篇文章。还要感谢我的老朋友Jean Sammet，她简直是“吓唬”我，让我不得不完成这篇文章——我真不敢想象如果迟交会发生什么。Sherri McLoughlin和Kim Rose在整理所有资料方面提供了莫大的帮助。

## 一、1960-66 年——面向对象编程的早期发展及六十年代其他形成性思想

尽管面向对象编程（OOP）的起源有很多，但其中有两个核心动机。宏观层面的动机是为涉及细节隐藏的复杂系统寻找更优的模块化方案，微观层面的动机是寻找更灵活的赋值方式，并最终尝试完全消除赋值。如同大多数新思想一样，OOP 最初也是断断续续、零散地发展起来的。

新思想的接受过程分为多个阶段，既有内部接受，也有外部接受。从内部来看，这一过程始于几次“勉强察觉”某种模式，然后注意到它却未能领悟其“宇宙级”意义，接着在多个领域实际运用它，随后经历一次“大转变”，该模式成为一种全新思维方式的核心，最终，它又会演变成最初与之背道而驰的那种僵化的宗教。从外部来看，正如叔本华所指出的，新思想最初会被斥为疯子的产物，几年后会被视为理所当然、司空见惯，最终，当初那些斥责它的人会声称自己才是它的发明者。

正如其发展历程所示，大约在1961年，我作为一名空军程序员时，曾几次“勉强”见过这种想法![b220 文件格式](image/smalltalk/b220.jpg)。第一次是在Burroughs 220计算机上，当时它被用作一种在空军训练司令部不同设施之间传输文件的格式。那时还没有标准的操作系统或文件格式，所以某个（至今身份不明的）设计师决定巧妙地解决这个问题，将每个文件分成三部分。第三部分是所有实际的数据记录，大小和格式不限。第二部分包含B220程序，这些程序知道如何访问记录和字段，以便复制和更新第三部分。第一部分是一个指向第二部分程序入口点的相对指针数组（初始指针按标准顺序排列，代表标准含义)。毋庸置疑，这是一个绝妙的想法，并在许多后续系统中得到应用，直到强制使用COBOL语言才最终将其淘汰。

第二次略微接触到这个概念是在不久之后，当时ATC决定用B5000取代220。那时我并没有真正领会它的价值，但我确实注意到它的分段存储系统、高效的高级语言编译和字节码执行、自动子程序调用和多进程切换机制、用于共享的纯代码、保护机制等等。而且，我发现它对程序参考表的访问方式与220文件系统中为模块提供过程接口的方案相对应。然而，当时这台机器给我留下最深刻印象的并非面向对象编程（OOP）的理念，而是对高级语言转换和求值的理解。[Barton, 1961] [Burroughs, 1961]

退伍后，我一边工作一边完成大学学业，主要工作是![摩尔定律图](image/smalltalk/mooreslaw.png)为美国国家大气研究中心编写大型气象数据集的检索系统程序。我对模拟产生了浓厚的兴趣——尤其是用一台机器模拟另一台机器——但除了在 CDC 6600 上用一维位域块传输 (bitblt) 算法模拟不同机器的字长之外，我的大部分精力都投入到了学校，或者更确切地说，是学校的戏剧社。在奇佩瓦福尔斯帮忙调试 6600 时，我读到了戈登·摩尔的一篇文章，他预测芯片上的集成硅将在未来很多年里在密度和成本方面呈指数级增长 [Moore 65]。当时是 1965 年，我站在那台房间大小、用氟利昂冷却的 10 MIP 6600 旁边，他那些惊人的预测对我来说几乎是天方夜谭。

### 草图板和开始

1966年秋天，机缘巧合之下，我进入了犹他大学的研究生院，当时我“一无所知”。也就是说，我之前从未听说过ARPA（美国高级研究计划署）及其项目，也不知道犹他大学在这个领域的主要目标是解决3D图形中的“隐藏线”问题，直到我走进戴夫·埃文斯的办公室，寻找工作和办公桌。戴夫的办公桌上堆着一摞棕色封面的文件，足足有一英尺高。他递给我一份：“拿着这个，好好读读。”

每个新人都拿到了一台。它的标题是“Sketchpad：人机图形通信系统”[Sutherland, 1963]。它的功能非常强大，与我之前接触过的任何计算机应用都截然不同。其中最容易理解的三个核心概念是：它是现代交互式计算机图形的开山之作；事物通过绘制“主图”来描述，主图可以生成“实例图”；控制和动态效果由同样以图形形式存在的“约束”来实现，这些约束可以应用于主图，从而塑造相互关联的各个部分。它的数据结构难以理解——唯一略微熟悉的结构是嵌入指向过程的指针，并使用一种称为反向索引的过程来跳转到相应的例程，类似于220文件系统[Ross, 1961]。它是第一个拥有裁剪和缩放窗口的系统——其中一个窗口“绘制”在一个大约三分之一平方英里的虚拟图纸上！

![素描本](image/smalltalk/sketchpad.png)

我晕头转向地找到自己的桌子。桌上堆着一摞磁带和清单，还有一张纸条：“这是1108型计算机的Algol程序。它运行不了。请帮我修好。” 最新来的研究生又被分配了一项棘手的任务。

这份文档令人费解。据说这是凯斯西储大学1107 Algol语言，但它被篡改成一种名为Simula的语言；文档读起来像是挪威语音译成英语，而事实上也的确如此。文档中出现了诸如*activity*和*process*之类的词语，其用法似乎与正常的英语用法不符。

最后，我和另一位研究生把程序清单展开，沿着走廊走了80英尺，然后爬过去仔细查看，互相大声宣布发现。最奇怪的是存储分配器，它没有像Algol那样遵循栈规则。几天后，这为我们提供了线索。Simula分配的是类似于Sketchpad实例的结构。其中包含一些描述，它们就像主对象一样，可以创建实例，每个实例都是一个独立的实体。Sketchpad称之为主对象和实例，Simula称之为活动和进程。此外，Simula是一种用于控制类似Sketchpad对象的程序化语言，因此比约束语言灵活得多（尽管牺牲了一些优雅性）[Nygaard, 1966, Nygaard, 1983]。

这对我来说是一次巨大的冲击，从此以后我的思维方式发生了改变。我认为它之所以如此震撼人心，是因为我曾以足够多的不同形式接触过这个理念，最终的领悟以一种非常普遍的方式呈现出来，如同醍醐灌顶。我的数学专业侧重于抽象代数，其少数几个运算通常适用于多种结构。我的生物学专业则专注于细胞代谢和更大规模的形态发生，其核心概念是简单的机制控制着复杂的过程，以及一种能够分化成所有所需构建模块的单一构建单元。220文件系统、B5000、Sketchpad，以及最终的Simula，都出于不同的目的运用了相同的理念。B5000的主要设计者、犹他大学教授鲍勃·巴顿几天前在一次演讲中说道：“递归设计的基本原则是使各个部分拥有与整体相同的能力。”我第一次将整体理解为整个计算机，并开始思考为什么有人会想要将其分割成被称为数据结构和过程的更弱小的部分。为什么不把它分成许多小型计算机，就像分时技术开始做的那样？但不是几十台，而是几千台，每台模拟一个有用的结构？

我想起了莱布尼茨的单子理论、柏拉图“从关节处分割自然”的论述，以及其他一些解析复杂性的尝试。当然，哲学关乎观点，工程关乎行动，而科学则介于两者之间，恰好是两者之间的一种平衡。毫不夸张地说，我此后的大部分想法都源于Simula——但并非为了改进它。真正吸引我的是它所展现的全新计算结构方式。事实证明，我花了相当长的时间才理解如何运用这些洞见，并设计出高效的执行机制。

## 二、1967-69 年——FLEX 机器，首次尝试基于面向对象编程的个人计算机

![韦斯·克拉克和LINC乐队，约1962年](image/smalltalk/linc.png)

戴夫·埃文斯并不十分看好研究生教育。和许多ARPA的“承包商”一样，他希望学生们能做“实际工作”；他们应该尽快完成研究生学业；而且他们的论文应该能够推动技术进步。戴夫经常为他的学生争取咨询工作，1967年初，他把我介绍给了埃德·切德尔，一位在当地一家航空航天公司工作的友善的硬件天才，当时他正在研发一台“小型机器”。这并非第一台个人电脑——那是韦斯·克拉克的LINC——但埃德希望它能被非计算机专业人士使用，尤其希望用像BASIC这样的高级语言来编写程序。我说：“JOSS怎么样？它更友好。”他说：“当然，你觉得怎么样就行。”就这样，我们开始了非常愉快的合作，共同开发了FLEX机器。随着设计的深入，我们意识到我们需要动态*模拟*和*扩展功能，*而JOSS（或者我所知的任何现有语言）在这两方面都不擅长。这台机器太小，Simula 无法运行，所以它被排除在外。JOSS 的精妙之处在于其设计对最终用户的极致关注——在这方面，它至今无人能及 [Joss 1964, Joss 1978]。JOSS 速度太慢，无法进行严肃的计算（但参见 Lampson 65），它没有真正的过程、变量作用域等等。Wirth 的 EULER 语言看起来有点像 JOSS，但功能却强大得多 [Wirth 1966]。它是 Algol 的推广，其思路最初由 van Wijngaarden [van Wijngaarden 1963] 提出，EULER 摒弃了类型，整合了不同的特性，将过程提升为一等对象等等。实际上，它有点像 LISP，但缺乏 LISP 的深刻内涵。

但欧拉法“几乎是全新的”，因此有人提出可以运用相同的技术来简化Simula。欧拉编译器是其形式化定义的一部分，能够简单地将其转换为类似B5000的字节码。这很有吸引力，因为它表明Ed的小型机器可以运行当时速度较慢、篇幅较长的微代码所模拟的字节码。然而，欧拉编译器被复杂地实现为一种“扩展优先级”语法，这实际上需要在语言语法上做出一些妥协（例如，“,”只能用于一种角色，因为优先级方案没有状态空间）。我最初采用了一种自底向上的Floyd-Evans解析器（改编自Jerry Feldman的原始编译器-编译器[Feldman 1977]），后来又尝试了各种自顶向下的方案，其中一些与Shorre的META II[Shorre 1963]相关，最终将翻译器置于语言的命名空间中。

如今被称为 FLEX 语言的语义需要更多地受到 Simula 的影响，而不是 Algol 或 EULER。但具体如何实现尚不完全清楚。用户应该如何与系统交互也同样不明确。Ed 的第一台机器就配备了显示器（用于绘图等），LINC 也配备了“玻璃电传打字机”，但像 Sketchpad 那样的系统似乎远远超出了我们预算范围内最多只能处理 16k 个 16 位字的能力范围。

### 道格·恩格尔巴特和NLS

![四张图片](image/smalltalk/nls.png)

那是1967年初，我们正在思考FLEX机器的时候，道格·恩格尔巴特（Doug Engelbart）来犹他州拜访了我们。他是一位堪称圣经预言家的人物，也是我当时在FLEX机器上开始称之为“个人计算”的先驱之一。他甚至随身带着一台16毫米放映机，还配有遥控器，可以随时启动和停止放映机，以便向大家展示正在发生的事情（当时人们还不习惯看到和跟随光标）。他对ARPA的设想是，在线系统（NLS）的未来在于通过一种交互式工具在“概念空间中的思维向量”中导航，从而“增强人类的智力”。即使以今天的标准来看，他的系统当时所能做到的事情也令人难以置信。它不仅支持超文本，还支持图形、多窗格、高效的导航和命令输入、交互式协作等等。它构建了一个完整的概念世界和世界观[Engelbart 68]。这一愿景的影响在于，它在那些“渴望增强自身能力”的人们心中创造了一个引人入胜的比喻，展现了交互式计算应该是什么样子，我立即将其中的许多想法应用到了 FLEX 机器上。

在ARPA关于人机共生的讨论氛围中，在埃德的“小机器”面前，戈登·摩尔的“定律”再次浮现在我的脑海，这一次，它带给我的震撼无比强烈。我第一次大胆地将房间大小的交互式TX-2，甚至是10 MIP 6600放在桌面上。我几乎被其蕴含的意义吓到了；我们所熟知的计算机技术将不复存在——“计算机”一词的真正含义发生了改变——这大概就像人们读了哥白尼的著作后，第一次从另一个地球仰望另一个天堂时所感受到的那种迷茫吧。

与其说全世界最多只有几千台机构用大型机——即使到了1992年，据估计全世界也只有4000台IBM大型机——以及最多几千名接受过每个应用程序培训的用户，不如说未来会有数百万台个人电脑和用户，而且大多不受机构的直接控制。应用程序和培训从何而来？我们凭什么指望应用程序员能够预见到数百万潜在用户中某个特定用户的具体需求？似乎需要一种*扩展*系统，让最终用户能够自行完成大部分工具的定制（甚至包括一些直接构建）。ARPA在早期分时技术的成功中已经意识到了这一点。他们提出的“人机共生”这一宏大概念，帮助整个社区避免将子目标奉为圭臬，并使他们始终专注于“增强”这一抽象的终极目标。

NLS 的一个有趣之处在于其用户界面是参数化的，最终用户可以以“交互语法”的形式，通过其编译器 TreeMeta 来提供界面。这与 William Newman 早期的“反应处理器”[Newman 66] 工作类似，后者通过让最终用户或开发者使用平板电脑和触控笔构建一个带有状态动作过程的图标式正则表达式语法来指定界面（NLS 允许通过其上下文无关规则进行嵌入）。这在很多方面都很有吸引力，尤其是 William 的方案，但我认为这种方法存在一个巨大的缺陷。也就是说，这些语法强制用户处于一个必须先退出的系统状态才能进行任何新的交互。在层级菜单或“屏幕”中，用户必须返回到主状态才能前往其他位置。似乎需要的是一种状态，其中每个状态之间都有一条过渡箭头——这在形式语法理论中并非一个有效的概念。换句话说，似乎需要一个更加“扁平化”的界面——但这样的界面能否变得足够有趣和丰富，从而变得有用呢？

同样，FLEX机器的规模对于miniNLS来说太小了，我们不得不寻找替代设计方案，以融合一些新理念的优势，并在某些情况下对其进行改进。我认为Sketchpad提出的能够查看更大虚拟世界的通用窗口的概念比受限的水平窗格更好，于是我和Ed一起提出了一种裁剪算法，该算法与当时Sutherland及其哈佛大学学生为3D“虚拟现实”头盔项目开发的算法非常相似[Sutherland 1968]。

在 FLEX 机器上，对象引用是通过对 B5000 描述符的泛化来处理的。与 B5000 中用于引用数字、数组和过程的几种格式不同，FLEX 描述符包含两个指针：第一个指向对象的“主”对象，第二个指向对象实例（后来我们意识到应该将主指针放在实例中以节省空间）。对于泛化赋值，FLEX 采用了不同的方法。B5000 使用左值和右值 [Strachey]，这种方法在某些情况下有效，但无法处理更复杂的对象。例如：如果a是一个默认元素为 0 的稀疏数组，那么*a[55] := 0*仍然会在数组中生成一个元素，因为 := 是一个“运算符”，在任何人看到右值是默认元素之前， *a[55]*就已经被解引用为左值，无论*a*是数组还是数组的前端过程。我们需要的是类似*a(55, ':=', 0) 的东西，*它可以在进行任何存储操作之前查看所有相关的操作数。换句话说，:= 不是一个运算符，而是一种索引，可以从一个复杂对象中选择一种行为。我花了很长时间才理解这一点，部分原因在于，我们需要颠覆传统的运算符和函数等概念，才能明白对象需要私有地拥有其所有行为：*对象是一种映射，其值就是它的行为*。卡尔纳普的逻辑学著作 [Ca ] 对此有所帮助，它表明“内涵”定义与更传统的外延技术涵盖了相同的领域，而且通常更直观、更方便。

![柔性机器图](https://worrydream.com/EarlyHistoryOfSmalltalk/Images/flex.png)

与 Simula 类似，协程控制结构 [Conway, 1963] 被用于挂起和恢复对象。文件和文档等持久化对象被视为挂起的进程，并根据其类似 Algol 的静态变量作用域进行组织。这些对象显示在屏幕上，可以通过鼠标指针打开。协程也被用作循环的控制结构。使用单个 while 运算符**来**测试生成器，当生成器无法提供新值时返回**false**。布尔值用于连接多个生成器。因此，“for 类型”循环可以写成：

```smalltalk
while i <= 1 to 30 by 2 ^ j <= 2 to k by 3 do j<-j * i;
```

其中，**...到...通过...**是一种协程对象。后来，Smalltalk 以更强大的风格重新实现了其中的许多概念。

![FLEX 当语句Ka 69](image/smalltalk/flexstatement.png)

FLEX 中另一个值得关注的控制结构是一种名为`when` 的事件驱动型“软中断”。它的布尔表达式被编译成一个“锦标赛排序”树，该树缓存了所有可能的中间结果。相关的变量会遍历所有 `when`中的所有排序树，这样任何更改都只需要计算布尔表达式的*必要*部分。效率非常高，类似于现在用于电子表格的技术。这带来了诸多优势，但也带来了事件驱动系统中常见的难题。具体来说，控制 ` when`何时应该生效是一个复杂的任务。必须使用布尔表达式的一部分来检查上下文，而我认为程序结构应该能够设置和取消设置事件驱动程序。事实证明，这超出了 FLEX 系统的范围，需要等待更好的架构出现。

尽管如此，FLEX 最初的许多想法，在其原型对象阶段，最终都证明足够小，可以在机器上运行。我正在编写第一个编译器时，发生了一件不同寻常的事情：犹他大学的研究生们受邀参加了当年在犹他州阿尔塔举行的 ARPA 承包商会议。在为期三天的会议即将结束时，接替伊万·萨瑟兰担任 ARPA-IPTO 负责人的鲍勃·泰勒询问研究生们（他们围坐在大约 20 位承包商的外围）是否有任何意见。约翰·沃诺克举手指出，既然 ARPA 的研究生们很快都会成为同事（而且反正我们才是真正干活的人），ARPA 应该每年为研究生们举办一次类似承包商会议的交流会。泰勒认为这是一个绝妙的主意，并安排在了第二年夏天举行。

那年春天晚些时候，我们在帕克城滑雪小屋又举行了一次会议。会议的主题是教育，也是我第一次听到马文·明斯基的演讲。他猛烈抨击了传统的教育方法，我第一次从他那里了解到了皮亚杰和帕珀特的理论。马文的演讲探讨了我们如何思考复杂的情境，以及为什么学校并不是学习这些技能的好地方。他无需提及“计算机+儿童”这个概念就能阐明他的观点。很明显，教育和学习必须根据20世纪认知心理学以及优秀思考者的真正思维方式进行重新思考。计算机作为一种新的表征系统，为处理复杂性，特别是系统复杂性，提供了新的、有用的隐喻[明斯基 70]。

![首款等离子面板](image/smalltalk/plasma.png)

1968年夏天，在伊利诺伊州阿勒顿庄园举行的ARPA研究生会议上，我把FLEX机器的所有机制简化成一张2英尺×3英尺的图表。图表包含了所有“对象结构”、编译器、字节码解释器、I/O处理程序以及一个简单的文本和图形显示编辑器。这些研究生非常优秀，后来也确实成为了我的同事。我的FLEX机器演讲很成功，但真正让我感到震撼的是参观伊利诺伊大学期间。在那里，我看到了一个1英寸见方的玻璃和氖气块，上面的单个点可以根据指令点亮——这是第一块平板显示器。在接下来的会议时间里，我一直在计算FLEX机器的硅芯片何时才能被安装到显示器背面。根据戈登·摩尔定律，答案似乎是在70年代末或80年代初。时间还很长——当时我觉得没必要为此过多担忧。

![Grail、Seymour Papert 和 LOGO Turtle，《Dynabook 模型》](image/smalltalk/dynabookmodel.png)

但同年晚些时候，我在兰德公司见到了一个真正美妙的系统。这就是 GRAIL，JOSS 的图形化后续版本。第一台平板电脑（著名的兰德平板电脑）由汤姆·埃利斯（Tom Ellis）发明 [Davis 1964]，用于捕捉人类手势，而加布·格罗纳（Gabe Groner）编写了一个程序来高效地识别和响应这些手势 [Groner 1966]。尽管所有部件都像用口香糖粘在一起一样简陋，而且系统经常崩溃，但我永远不会忘记与这个系统的第一次互动。它是直接操作的，它是模拟的，它是无模式的，它美极了。我意识到 FLEX 界面完全错误，但像 GRAIL 这样的东西怎么能塞进这么小的机器里呢？毕竟它需要一台完整的独立 360/44 才能运行。

一个月后，我终于拜访了西摩·帕珀特、沃利·费尔齐格、辛西娅·所罗门以及其他一些LOGO的早期研究人员，他们开发了LOGO，并在列克星顿的学校里用它来教孩子们编程。孩子们正在使用一种专门设计的语言和环境进行真正的编程。就像Simula引领了面向对象编程（OOP）一样，这次经历最终让我明白了个人计算的*真正*命运。它并非像恩格尔巴特用“个人动态*交通工具*”来比喻IBM的“铁路”，而是更深刻的东西：一种个人动态*媒介。*如果是交通工具，我们可以等到高中再进行“驾驶培训”，但如果是一种媒介，它就必须延伸到童年时代。

如今，FLEX 机器、平板显示器、GRAIL、巴顿的“通信”演讲、麦克卢汉以及帕珀特与儿童合作的研究成果汇聚在一起，共同勾勒出个人电脑的真正面貌。我想起了阿尔杜斯·马努提乌斯，他在印刷术发明 40 年后，通过让书籍能够装进马鞍袋，使之成为现代书籍。它必须比笔记本大不了多少，界面要像 JOSS、GRAIL 和 LOGO 一样友好，但功能要像 Simula 和 FLEX 一样强大。清晰而浪漫的愿景具有凝聚思想和意志的神奇力量。现在，下一步该做什么就显而易见了。我用硬纸板制作了一个模型，看看它的外观和手感，并在里面倒入铅丸，看看它必须有多轻（不到两磅）。我给它配了键盘和触控笔，因为即使手写输入能够被完美识别（虽然没有理由期待它能做到），仍然需要在触控笔提供的低速触觉自由度和键盘虽然速度更快但功能有限的特性之间找到平衡。由于ARPA当时已经开始试验分组无线电技术，我预计十年左右后推出的Dynabook将会配备无线网络系统。

次年年初（1969年），召开了一次可扩展语言会议，几乎所有该领域的知名人士都出席了。会议辩论激烈而重要——这是一场关于未经实现、考虑不周的理念的宗教战争。正如计算机科学界的伟人之一艾伦·珀利斯（Alan Perlis）以其特有的机智所言：

> 我已经很久没有看到这么多熟悉的面孔在这么多熟悉的想法中欢呼雀跃了。在编程语言中发现新事物，就像任何其他发现一样，其情感起伏与坠入爱河有些相似。先是强烈的兴奋，然后是欣喜若狂，一种独特感，最终是目光游移（想要概括的冲动）[ACM 69]。

但这都只是空谈——没有人采取任何行动。就在这时，内德·艾恩斯站出来提出了IMP系统。该系统已经运行了好几年，比大多数不可行的方案都更加优雅。IMP的基本思想是，你可以使用语法中的任何短语作为过程标题，并根据目前扩展的语言编写语义定义[Irons 1970]。

我之前已经完成了FLEX机器的第一个语法驱动版本，但其中短语的含义是以更常见的方式定义的，即它所生成的代码类型。这使得系统的编译器/扩展器部分与最终用户分离。在Irons的方法中，系统中的*每个*过程都以自然且实用的方式定义了自己的语法。我将这些想法融入到FLEX机器的第二个版本中，并开始尝试使用直接解释器而不是语法驱动的编译器。在此过程中，我意识到，通往面向对象系统的桥梁可以建立在将每个对象视为发送给它的消息的语法驱动解释器的基础上。这将一举将面向对象的语义与完全可扩展语言的理想统一起来。我的设想是，不同的计算机向其他计算机发送请求，这些请求必须被接收者接受和理解后才能进行后续操作。用今天的术语来说，每个对象都可以是一个*服务器，*提供*服务*，服务的部署和使用完全取决于服务器与服务接收者之间的关系。正如莱布尼茨所说：“要想无中生有，你只需要找到一个原则。” 这句话虽然不够周全，对FLEX机器没有任何帮助，但却为我的论文[Kay 69]提供了一个很好的出发点，正如伊万·萨瑟兰喜欢说的那样，我的论文就是“任何你能找到三个人签字的东西”。

在三个人（伊万是其中之一）签字后，我去了斯坦福人工智能项目，花在思考笔记本式儿童电脑上的时间远比人工智能本身要多。不过，有两个人工智能设计非常吸引我。第一个是卡尔·休伊特的PLANNER，这是一个可编程逻辑系统，构成了温诺格拉德的SHRDLU的演绎基础[Sussman 69, Hewitt 69]。我基于FLEX和PLANNER的模式匹配方案的组合设计了几种语言[Kay 70]。第二个设计是帕特·温斯顿的概念形成系统，这是一个构建语义网络并进行比较以形成类比和学习过程的方案[Winston 70]。它有点像“面向对象”的。它的众多优点之一是，作为AOV三元组属性的每个网络的弧本身也应该建模为网络。因此，例如，可以向一个名为LEFT-OF的一阶弧提出一个高阶问题，例如“你的逆是什么？”，而它的网络可以回答：RIGHT-OF。这种观点后来成为明斯基框架体系的基础[明斯基 75]。几年后，我后悔当初没有更重视这个想法。

那年秋天，我听了巴特勒·兰普森（Butler Lampson）关于CAL-TSS的精彩演讲。CAL-TSS是一个基于能力的操作系统，看起来非常“面向对象”[Lampson 69]。不可伪造指针（类似于B5000）通过位掩码进行扩展，限制了对对象内部操作的访问。这印证了我之前关于“对象即服务器”的比喻。此外，CAL-TSS还采用了一种非常巧妙的异常处理方法，让我想起了模式匹配系统中常见的故障处理方式。唯一的问题——CAL的设计者们却完全没有意识到——是只有某些特定的东西（通常是体积庞大且运行缓慢的）才被视为“对象”。运行速度快、体积小等等的东西则不被视为对象。这个问题亟待解决。

1969 年末在 SAIL 学习期间，我最大的收获莫过于*真正理解了*LISP。当然，每个学生都知道`car`、`cdr`和`cons` ，但犹他州的情况比较特殊，因为那里没人用 LISP，因此也没人真正领悟过`eval`和`apply`的奥秘。我简直不敢相信 LISP 的理念如此美妙绝伦 [McCarthy 1960]。之所以这么说，是因为 LISP 不仅发展到一定程度后沾染了一些顽疾，更糟糕的是，它的逻辑基础存在着严重的缺陷。我的意思是，这门纯粹的语言本应基于函数，但它最重要的组成部分——例如 lambda 表达式、引用和条件——根本不是函数，而是被称为特殊形式。Landin 和其他人通过各种巧妙而实用的技巧，成功地用 lambda 表达式表示了引用和条件，但这颗宝石的缺陷依然存在。在实际应用中，情况则要好得多。不仅有 EXPR（会求值其参数），还有 FEXPR（不会求值）。我的下一个问题是，为什么它被称为函数式语言？为什么不完全基于 FEXPR，并在需要时强制接收方进行求值呢？我始终没能找到一个令人满意的答案，但这个问题在发明 Smalltalk 时却非常有用，因为它开启了一种思路：“找到你需要做的最难、最深刻的事情，把它做到极致，然后以此为基础构建所有更简单的功能。” 这就是 LISP 的承诺和 lambda 表达式的吸引力所在——我们需要一个更优秀的“最难、最深刻”的事情。对象应该就是它。

## 三、1970-72 年——施乐帕克研究中心：KiddiKomp、miniCOM 和 Smalltalk-71

1970年7月，在首席科学家杰克·戈德曼的敦促下，施乐公司决定在加利福尼亚州帕洛阿尔托设立一个长期研究中心。同年9月，华盛顿大学前校长乔治·帕克（韦斯·克拉克的ARPA项目就设在该校）聘请了鲍勃·泰勒（他当时已离开ARPA办公室，正在犹他州休假一年）来筹建一个“计算机科学实验室”。鲍勃来帕洛阿尔托拜访，我们彻夜长谈。当时，《曼斯菲尔德修正案》正威胁着要盲目地扼杀ARPA最开明的资助，转而支持直接的军事研究，而这个新机会看起来是一个很有前景的替代方案。但是，为一家公司工作？他想让我做顾问，我便请他指点方向。他说：跟着感觉走。我立刻开始着手开发KiddiKomp的新版本，以便能够批量生产，进行实验，最终设计出笔记本电脑的用户界面。鲍勃·巴顿常说：“好点子往往难以规模化。”他的观点在应用于FLEX机器时确实是正确的。B5000无法直接缩小成一台小型机器。只有字节码可以缩小，但即使是字节码也需要修改。我决定重新审视韦斯·克拉克的LINC程序，这一次我准备更加欣赏它[Clark 1965]。

![KiddiKomp](image/smalltalk/kiddikomp.png)

我仍然喜欢模式导向的方法和面向对象编程，所以我设计了一种名为“模拟LOGO”（简称SLOGO）的语言（我预感最初的版本运行速度可能会很慢）。这套系统计划集成到索尼的“腹部特丽珑”电视中，使用粗糙的位图显示屏和FLEX机器的橡胶触控板作为指点设备。

我遇到的另一个很棒的系统是彼得·德意志（Peter Deutsch）的PDP-1 LISP（他15岁时就实现了它）[Deutsch 1966]。它只用了2K（18位字）的代码，就能在4K机器上流畅运行（它本身就是一个操作系统和接口）。如果将系统编码成字节码，运行在一个对动态系统友好的架构上，并嵌入到当时越来越大的ROM中，似乎还能做得更好。我从西摩那里得到的一个重要启示是，你不需要做太多就能让计算机成为孩子们“思考的对象”，但你所做的必须做好，并且能够深入应用。

1971年新年刚过，鲍勃·泰勒就取得了一项重大成就，他成功地将当时举步维艰的伯克利计算机公司的大部分员工吸引到了帕洛阿尔托研究中心（PARC）。这批员工包括巴特勒·兰普森、查克·萨克、彼得·德意志、吉姆·米切尔、迪克·舒普、威利·苏·豪格兰德和埃德·菲亚拉。吉姆·米切尔力荐他们从CM公司聘请埃德·麦克雷特，麦克雷特很快就加入了PARC。加里·斯塔克韦瑟此前已在PARC工作，他因为想研发激光打印机（这与当时的理念相悖）而被施乐罗切斯特实验室开除。不久之后，道格·恩格尔巴特的许多团队成员也加入了PARC——部分原因是他们想将NLS重新实现为一个分布式网络系统，而道格则希望继续使用分时技术。这批员工包括比尔·英格利希（鼠标的共同发明人）、杰夫·鲁利夫森和比尔·帕克斯顿。

我们几乎立刻就和施乐公司起了冲突，因为团队决定新实验室需要一台PDP-10，以保持与ARPA社区的联系。施乐公司（几年前几乎没看过实物就收购了SDS）对实验室使用其主要竞争对手的计算机感到震惊，并坚决反对。新成立的PARC团队开会决定，为XDS SIGMA-7开发一个完善的操作系统大约需要三年时间，但我们可以在一年内*构建*“我们自己的PDP-10”。我的反应是“我的天哪！”事实上，他们以相当出色的方式完成了这项工作。MAXC实际上是PDP-10的微代码模拟，它首次使用了新型集成芯片存储器（1K位！），而不是磁芯存储器。拥有这两种新技术的实际内部经验对于未来更激进的系统至关重要。

艾伦·纽厄尔带着他的层级思维理论访问帕克研究中心时，曾发生过一件展现LISP之美的小插曲。当时，他被要求证明自己的理论。在收集实验数据的同时，他被布置了一个编程任务。问题是：给定一个元素列表，生成一个列表，该列表先包含所有奇数索引的元素，再包含所有偶数索引的元素。纽厄尔的内部编程语言类似于IPL-V，其中指针的操作是显式的，因此他在编写这个程序时遇到了相当大的困难。我只用了两秒钟就写下了：

```lisp
oddsEvens(x) = append(odds(x), evens(x))
```

用 Landin 的 LISP 语法描述问题——同时也是解决方案的第一部分。几秒钟后：

```lisp
where odds(x) = if null(x) ∨ null(tl(x)) then x
                   else hd(x) & odds(ttl(x))
     evens(x) = if null(x) ∨ null(tl(x)) then nil
                   else odds(tl(x))
```

这种以声明式形式编写多种解决方案并将其作为程序的特性，正是此类语言的魅力所在。看着一位比我聪明得多的名人苦苦钻研了30多分钟，却仍然无法用他的方法解决问题（因为存在一个bug），这给我留下了深刻的印象。这件事再次让我意识到“视角胜过80个智商点”。我并不比他聪明，但我拥有了更强大的内在思维工具来提升我的能力。这件事以及其他类似的事情让我更加深刻地认识到，任何儿童教具都应该“内置”优秀的思维模式和深刻的艺术美感。

![彭德里纸张显示传感器设计](image/smalltalk/penderypaperdisplay.png)

就在这个时候，我们和施乐管理层，特别是首席“规划师”唐·彭德里，又发生了一次冲突。他根本不理解我们讨论的内容，反而对“趋势”、“未来会是什么样子”以及施乐该如何“应对”未来感兴趣。我当时非常生气，对他说：“听着，*预测未来的最好方法就是创造未来。*别担心其他人会做什么，在这个世纪，几乎任何清晰的愿景都能实现！”但他仍然不为所动，这最终促成了著名的《彭德里PARC规划论文集》的诞生，这是一部关于未来各个方面的文章合集。我的论文提出了一种将笔记本电脑作为“显示转换器”的方案，而吉姆·米切尔的论文题为《小型计算机上的非线性扫描》。

比尔·英格利希（Bill English）对我关怀备至，帮助我组建团队，因为我一直是个独行侠，完全不知道该怎么做。他给我的建议之一是制定预算。恐怕我真的问过比尔：“什么是预算？” 我记得在犹他州，曼斯菲尔德修正案通过之前，戴夫·埃文斯（Dave Evans）去ARPA出差时对我说：“我们的钱快用完了，得再去弄点儿。” 我觉得这话挺有道理的。他们给你一些钱，你用这些钱去研究下一步该做什么，然后钱又用完了，他们再给你一些，如此循环往复。PARC从未达到过那种理想状态，但在最初的五年里，它已经非常接近了。我需要一个团队，因为我终于意识到，我并不具备完成一个想法所需的所有素质。我把它叫做学习研究小组（LRG），尽量模糊我们的章程。我只雇佣那些一听到笔记本电脑的想法就兴奋不已的人。我不喜欢开会：我不相信头脑风暴能代替冷静而持续的思考。每当有人问我该做什么，而我又没有明确的想法时，我就会指着笔记本模型说：“推进这个。”学习研究小组的成员之间建立了非常密切的关系——正如丹·英格尔斯后来所说：“……其余的一切都源于整个学习研究小组的爱与活力。”白天的大部分时间我们都待在PARC之外，打网球、骑自行车、喝啤酒、吃中餐，并且不断地讨论Dynabook及其潜力，它能够扩大人类的影响范围，并为当时正处于衰落、急需变革的文明带来新的思维方式（这种目标在六十年代后的加州很常见）。

1971年夏天，我将KiddiKomp的构想完善成一个更紧凑的设计，名为miniCOM。它采用了类似NOVA 1200的位切片方法，配备了位图显示器、指点设备、多种“辅助”（实际上是第三级）存储空间，以及一种我称之为“Smalltalk”的编程语言——取自“编程应该是一件……的事情”和“孩子们应该用……编程”的寓意。这个名字也是对“印欧神论”的一种反驳，在印欧神论中，系统被命名为宙斯、奥丁和托尔，但实际上却几乎什么功能都没有。我认为“Smalltalk”这个名字如此无害，如果它真的能做出什么好东西，人们一定会感到惊喜。

![迷你电脑](image/smalltalk/minicom.jpg)

```smalltalk
Smalltalk-71 程序

to T 'and' :y do 'y' 
to F 'and' :y do F 

to 'factorial' 0 is 1 
to 'factorial' :n do 'n*factorial n-1' 

to 'fact' :n do 'to 'fact' n do factorial n. ^ fact n' 

to :e 'is-member-of' [] do F 
to :e 'is-member-of' :group 
          do'if e = firstof group then T 
		          else e is-member-of rest of group' 

to 'cons' :x :y is self 
to 'hd' ('cons' :a :b) do 'a' 
to 'hd' ('cons' :a :b) '<-' :c do 'a <- c' 
to 'tl' ('cons' :a :b) do 'b' 
to 'tl' ('cons' :a :b) '<-' :c do 'b <- c' 

to :robot 'pickup' :block 
         do 'robot clear-top-of block. 
		 robot hand move-to block. 
		 robot hand lift block 50. 
		 to 'height-of' block do 50'
```

这种 Smalltalk 语言（如今标记为 -71）深受 FLEX、PLANNER、LOGO、META II 以及我基于它们衍生出的语言的影响。它是一种带有对象附加功能的解析器，可以直接执行标记。（我认为它那略显笨拙的引用约定源自 META）。我当时对程序作为代数模式的兴趣远不如对能够处理各种编程风格的清晰方案感兴趣。这种模式化的前端允许简单的扩展，模式可以作为“数据”检索，可以轻松地将行为附加到对象上，并且以一种我认为孩子们在几年简单的编程经验后就能理解的语言，对它的*求值*过程进行了简明扼要但清晰的表达。程序存储被分类到一个区分网络中，而求值过程则是直接的模式匹配。

正如我之前提到的，LISP 表面上的美感令人恼火，因为它的一些关键部分不得不以“特殊形式”而非其原本应有的通用函数构建模块的形式引入。LISP 的真正魅力更多地来自于其元结构的*潜力*，而非其实际模型。我花了不少时间思考如何才能将对象描述为通用计算机，而无需在核心隐喻中设置任何例外。似乎需要的是对消息发送过程中传递的内容的完全控制；特别是表达式*何时*以及在*何种环境*下进行求值？

戴夫·费舍尔 (Dave Fisher) 在卡内基梅隆大学 (CMU) 的论文 [Fisher 70] 中提出了一种关于控制结构综合的巧妙方法。ALGOL60 需要单独的链接来实现动态子程序链接和访问静态全局状态。费舍尔展示了如何利用这些链接的泛化来模拟各种控制环境。解决 LISP 的“函数问题”的方法之一是将合适的全局状态链接与稍后需要求值的表达式和函数关联起来，从而确保引用的自由变量是语言静态形式实际隐含的变量。这里也预示了“惰性求值”的概念。

如今，这种方法被称为*反射式设计*。将其与 FLEX 模型结合起来，表明“正确地编写 LISP”或“正确地编写 OOP”所需的仅仅是处理模块间调用机制，而无需关心模块本身的细节。LISP 与 OOP（或任何其他系统）的区别就在于模块可以包含什么。一个通用的模块（对象）引用——类似于 B5000 和 LISP——以及一个消息存储结构（如果发送方和接收方相互理解，该结构可以是虚拟的），供所有人使用，就能满足需求。

如果按照这种观点枚举消息传递结构的所有字段，我们将得到：

| 全球的：     | *参数值的环境*     |
| ------------ | ------------------ |
| 发件人：     | *消息发送者*       |
| 接收者：     | *信息的接收者*     |
| 回复样式：   | *等等，叉子……？*   |
| 地位：       | *消息进展*         |
| 回复：       | *最终结果（如有）* |
| 操作选择器： | *相对于接收器*     |
| 参数数量：   |                    |
| P1：        |                    |
| ……：         |                    |
| Pn：         |                    |

这是对 B5000 等堆栈帧的概括，与 CAL-TSS 等操作系统中良好的模块间方案的要求非常相似——每个事务都需要大量的状态，但值得思考。

在这段灵感迸发的时期（在任何可行的实施方案出现之前），大部分思考都围绕着如何理解“美”在面向对象设计中的含义。对美的事物做出主观定义很容易，但却意义不大：我们认为某件事物美，是因为它能唤起某些情感。俗话说“情人眼里出西施”，因此很难将美理解为主体与客体之间关系之外的事物，而主体的主观倾向在其中扮演着至关重要的角色。

如果真存在某种普世皆宜的美，那么或许我们可以从共同的生物遗传中寻找其内在倾向。但是，对于像LISP这样的对象而言，几乎可以肯定的是，我们判断其美的标准大多是后天习得的，并且与我们认为美的其他相关领域（例如数学的很多方面）密切相关。

数学之美的一部分在于其简洁性、普遍性、启发性和精妙性之间奇妙的协同作用。例如，勾股定理可以用一行公式表达，适用于所有无穷多个直角三角形，在理解许多其他关系方面非常有用，并且可以通过几个简单而深刻的步骤证明。

当我们研究各种用于描述计算的语言时，会发现许多语言通用性强，少数语言则简洁高效。例如，我们可以用几条指令定义通用机器语言，它能够描述任何可计算的内容。但我们不会称大多数这类语言为“优美”，部分原因是，要实现任何有趣的功能，都需要编写大量且冗长的代码。一个能够实现有趣功能的简单小系统也需要具备“高斜率”——也就是说，趣味性与表达它所需的复杂度之间需要高度匹配。

一个受精卵能够蜕变为构成复杂生物体所需的无数特化结构，它兼具简约性、普遍性、智慧性和精妙性——简而言之，它拥有美，而且这种美更符合我的审美观。我的意思是，大自然在优雅和实用性方面都堪称奇妙——细胞膜的存在，一方面是为了允许进化过程中那些有用的权宜之计发挥其必要作用，另一方面又能通过向外界呈现统一的界面，使细胞本身成为一个组成部分。

当时我一直担心位图显示器的尺寸。即使采用混合模式（精细生成的字符和用于图形的粗粒度通用位图相结合），也很难在屏幕上显示足够的信息。我突然想到（当时我正在淋浴，这是我最喜欢的思考场所），位图显示器上的 FLEXtype 窗口可以像桌面上的重叠文档一样排列。当刷新重叠的窗口时，它会显示在窗口堆栈的顶部。当时，这看起来并不是解决问题的完美方案，但它的确能极大地扩展显示的有效区域，所以我决定采用这种方法。

为了研究视频作为显示媒介的应用，比尔·英格利希和巴特勒·兰普森为POLOS（PARC在线办公系统）终端指定了一台实验性字符生成器（由罗杰·贝茨制造）。加里·斯塔克韦瑟刚刚成功研制出第一台激光打印机，我们便用同轴电缆连接到他的实验室，给他传输一些文本进行打印。这台“扫描激光输出终端”（SLOT）简直令人难以置信。加里唯一能用的施乐复印机每秒只能打印一页，而且无法减速。于是，加里干脆让激光打印机以同样的速度运行，分辨率却达到了每英寸500像素！

字符生成器的字体内存容量足够大，只要显示一个固定的“笔画”并写入字体内存，就能模拟位图显示。本·劳斯开发了一个漂亮的字体编辑器，我和他花了几个月的时间研究人类视觉系统的特性（它显然是非线性的）。我对高质量的文本和图形呈现非常感兴趣，因为我认为与其费力地向教师和学校董事会解释个人电脑的真正优势，不如直接用 Dynabook 取代课本，这样更容易让 Dynabook 像“特洛伊木马”一样进入学校。

![旧式字符生成器——1972年初](image/smalltalk/oldcharacter.jpg)]

实验室里一切进展顺利，直到1972年5月，我试图争取资源来搭建几台迷你计算机。一位新上任的主管（“X”）不愿把资源给我。我写了一份备忘录，解释了这套系统为何可行（见附录二），然后召开了一次会议进行讨论。“X”断然否决了这项计划，理由之一是我们之前为了让施乐公司资助分时MAXC项目而耗费了太多资金，把资源用在个人电脑上会让他们感到困惑。我当时震惊不已。我只好回到实验性的字符生成器旁，制定了一个计划，再制作4台，并将它们连接到NOVA芯片上，用于最初的儿童实验。

我请斯坦福大学的暑期学生史蒂夫·珀塞尔（Steve Purcell）帮我搭建位图绘画系统，这样孩子们既可以画草图，也可以展示计算机图形。约翰·肖克（John Shoch）搭建了一个线条绘制和手势识别系统（基于莱丁（Ledeen）的[Newman and Sproull 72]），并将其集成到绘画系统中。POLOS公司的比尔·杜瓦尔（Bill Duvall）搭建了一个miniNLS，速度和性能都非常出色。第一批重叠窗口开始出现。鲍勃·舒尔（Bob Shur）（在史蒂夫·珀塞尔的帮助下）搭建了一个2.5D动画系统。再加上本·劳斯（Ben Laws）的字体编辑器，我们能够展示一个非常精彩的演示，展示我们计划在未来几年内真正开发的东西。我记得我把其中一个演示送给了施乐公司的一位高管，包括用新的绘画系统为他画了一幅肖像，最后我得意洋洋地宣布：“这最棒的地方在于它只有20%的成功率。我们正按照您的要求承担风险！”他直视着我的眼睛说：“伙计，这很棒，但一定要确保它有效。” 这是典型的管理者对风险的看法。他希望我们始终保持在“20%”的成功率之内。

![第一套绘画系统——1972年夏季](image/smalltalk/firstpainting.jpg)

那年夏天，我一边舔舐伤口，一边搭建并运行演示模拟程序。与此同时，巴特勒·兰普森、彼得·德意志和我一起制定了一个模拟高级语言机器语言的通用方案。我喜欢B5000方案，但巴特勒不想解码字节，他指出，由于一个8位字节总共有256种可能性，我们应该做的是将不同的含义映射到“指令空间”的不同部分。这样就能得到一个既灵活又简单的“简易版霍夫曼编码”。之后PARC的所有模拟器都采用了这个通用方案。

我还重新审视了孩子们使用的语言。杰夫·鲁利夫森是皮亚杰（以及符号学）的忠实拥趸，我们曾多次讨论过“阶段”以及图像思维的本质。在阅读了皮亚杰，尤其是杰罗姆·布鲁纳的著作后，我担心FLEX、LOGO（以及现在的Smalltalk）所采用的直接符号化方法对孩子们来说难以理解，因为有证据表明，符号阶段（或心智）才刚刚开始启动。事实上，所有我敬佩的教育家（包括蒙特梭利、霍尔特和铃木）似乎都呼吁采用更具形象化、更图像化的方法。鲁道夫·阿恩海姆[Arnheim 69]和著名艺术评论家贡布里希[Gombrich **]都曾撰写过关于视觉思维的经典著作。看来确实需要一些更好的方法。GRAIL并非理想之选，因为它使用图像来描绘和编辑流程图，这似乎是一种倒退。但罗夫纳的 AMBIT-G 看起来更有前景 [罗夫纳 68]。它有点像视觉版的 SNOBOL [法伯 63]，而且它的模式匹配理念似乎很适合我当时使用的更像 PLANNER 的方案。

比尔·英格利希仍然鼓励我做一些看起来更合理的事情来提升信誉，比如制定预算、撰写计划和里程碑报告。所以我写了一份计划，提议在接下来的几年里，基于字符生成器*和*NOVA 构建一个真正的系统，该系统将涉及面向对象编程 (OOP)、窗口、绘画、音乐、动画和“图标编程”。后者被认为难度较大，将采用解决难题的常用方法，即交给研究生。

![来自《适合所有年龄段儿童的个人电脑》的儿童与 Dynabook [Ka 72\]，1972 年 LRG 计划中的标志性泡泡排序 [Ka 72a]](image/smalltalk/childrenwithdynabooks.png)

## 四、1972-76 年——第一个真正的 Smalltalk（-72），它的诞生、应用和改进

九月份，短短几周内，发生了两件打赌的事，彻底改变了我的大部分计划。先是巴特勒和查克过来问我：“你有钱吗？”我说：“有，大概23万美元，用来做NOVA和CG。怎么了？”他们问：“你想让我们帮你造一台什么样的机器？”我说：“我挺好的。你想要什么？”巴特勒说：“我想要一台‘500美元的PDP-10’，查克想要一台‘速度快10倍的NOVA’，而你想要一台‘儿童电脑’。你需要什么功能？”我把我们在字体、绘画、分辨率、动画和音乐研究方面取得的大部分成果告诉了他们。我问这事怎么突然冒出来了，巴特勒告诉我他们本来就想做，X主管要去参加一个“特别行动小组”几个月，所以他们或许可以“偷偷摸摸地搞定”，而且查克还跟比尔·维蒂奇打赌，说他能在短短三个月内造出一台完整的机器。“哦，”我说。

第二个赌注的结果更加出人意料。我原本以为新的 Smalltalk 会成为一种标志性语言，至少需要两年时间才能开发完成，但命运却另有安排。一天，在帕克研究中心（PARC）走廊里，我和 Ted Kaehler、Dan Ingalls 闲聊着编程语言。话题聊到了“权力”，他们俩琢磨着，要开发出一种多么强大的语言才行。我故作自信地断言，世界上“最强大的语言”可以用“一页代码”来定义。他们说：“要么拿出证据，要么闭嘴。”

泰德回了卡内基梅隆大学，但丹还在我身边怂恿我。接下来的两周，我每天早上四点就到PARC，一直工作到八点，丹会和亨利·福克斯、约翰·肖克以及史蒂夫·珀塞尔一起过来，对上午的工作指指点点。

我最初之所以夸下海口，是因为麦卡锡的自描述 LISP 解释器完全是自己编写的。它只有“一页纸”长，就功能而言，LISP 是函数式语言的巅峰之作。我非常确信，我不仅能为面向对象语言编写出类似的解释器，还能像FLEX 机器技术那样，为代码编写出合理的语法。

事实证明，这比我最初想象的要困难得多，原因有三。首先，我希望程序更像麦卡锡的第二个非递归解释器——它用循环实现，并尽可能地模仿史蒂夫·罗素最初的709实现。它更“真实”。其次，由于“解析”与消息接收（参数求值在LISP中是单独处理的）交织在一起，我的面向对象解释器需要比LISP“更早”（实际上是早得多）地重新进入自身。最后，我仍然不清楚*发送*和*接收*应该如何协同工作。

最初的几个版本存在缺陷，受到了小组的严厉批评。但到了早上八点左右，出现了一个似乎可以正常工作的版本（解释器的设计概要见附录三）。与稍晚发布的官方 Smalltalk-72 相比，主要区别在于：在第一个版本中，符号采用字节编码，并且接收 send 函数返回值的方式是对称的——也就是说，接收可以像参数绑定一样进行——这对于返回多个值尤其有用。由于各种原因，这种对称方式被放弃，转而采用更面向表达式的函数式返回风格。

当然，我费尽心思避免为了打赌而做任何“实际工作”，但我感觉我已经证明了自己的观点。这次假期让我们暂时摆脱了正式的“标志性编程”工作，我觉得事情到此为止就结束了。令我惊讶的是，仅仅几天后，丹·英格尔斯就向我展示了在NOVA上运行的方案。他用BASIC语言编写了代码，添加了许多细节，例如令牌扫描器、列表生成器等等，而且它真的运行起来了。正如他常说的：“你只要动手，一切就搞定了。”

它计算*3+4 的* 速度非常慢（正如巴特勒喜欢说的，简直是“冰川般缓慢”），但答案始终是 7。好吧，除了继续下去别无他法。丹喜欢在一个“永远运行”的系统上进行自举式开发，在接下来的十年里，他至少发布了 80 个不同版本的 Smalltalk 主要版本。

11月，我向麻省理工学院人工智能实验室展示了这些想法以及解释方案的演示。这最终促成了卡尔·休伊特（Carl Hewitt）更为正式的“Actor”方法[Hewitt 73]。在第一篇Actor论文中，它与Smalltalk最为相似。之后，我们的发展方向有所不同，部分原因是我们更热衷于实践而非理论探讨，部分原因是我们拥有别人没有的东西：查克·萨克（Chuck Thacker）的临时Dynabook（后来被称为“ALTO”）。

就在查克开始着手研究那台机器之前，我向美国国家英语教师委员会提交了一篇关于Dynabook及其作为学习和思维放大器的潜力的论文[Kay 72c]——这篇论文是一篇篇幅很长的凹版印刷作品，介绍了“Dynabook的20种用途”[Kay 72c]。等我从明尼苏达州回来的时候，斯图尔特·布兰德关于PARC[Brand 1972]及其周边黑客社区的《*滚石》杂志*文章已经出版了。令我们大吃一惊的是，这篇文章在位于康涅狄格州斯坦福德的施乐公司总部引起了轩然大波。尽管这是一篇精彩的文章，真正捕捉到了整个黑客文化的精神，但施乐公司却勃然大怒，强迫我们佩戴徽章（多年来，许多徽章都被印在了T恤上），并严格限制了我们可以出版的刊物类型。这对 LRG 来说尤其具有灾难性，因为我们是“疯子边缘群体”（其他计算机科学家如此称呼我们），我们计划走进校园，需要与 Seymour Papert 和 Don Norman 等同事分享我们的想法（和程序）。

高管“X”显然在斯坦福听到了一些关于我们的难听话，因为他圣诞节前后回来后，得知了临时版Dynabook的存在，更加恼火，试图扼杀它。巴特勒最终写出了一篇精彩的辩护文章，成功阻止了他，之后他才回到自己的“特别工作组”。

![BILBO，第一台“过渡型 Dynabook”，以及它展示的第一批图像“饼干怪兽”。1973年4月](image/smalltalk/bilbo.jpg)

查克于1972年11月22日开始了这项“挑战”。他和两位技术人员完成了除磁盘接口（由埃德·麦克雷特完成）之外的所有机器工作。它配备了一块约50万像素（606x808）的位图显示屏，微代码指令速率约为6 MIPS，总容量为128k，整台机器（不包括内存）由分布在两张卡上的160个MSI芯片构成。它非常精美[Thacker 1972, 1986]。这台机器的一大亮点是“零开销”任务处理。它有16个程序计数器，每个任务对应一个。条件标志与一些重要事件（例如“水平回扫脉冲”和“磁盘扇区脉冲”等）相关联。旁路逻辑会在当前指令执行期间扫描这些标志，并选择优先级最高的程序计数器进行下一次读取。这台机器无需等待，因此大多数硬件功能（尤其是那些涉及输入/输出的功能，例如向显示器提供数据和处理磁盘）都可以用微代码替代。甚至连MOS动态RAM的刷新也是由一个任务完成的。换句话说，这是一种协程架构。查克声称他的灵感来自几个月前我关于协程的讲座，但我记得韦斯·克拉克的TX-2（Sketchpad机器）才是第一个使用这种理念的人，而且我可能在讲座中提到过这一点。

四月初，距离项目启动仅仅三个多月，第一台临时 Dynabook（名为“Bilbo”）问世，几分钟之内，屏幕上就出现了第一张位图图像：我在我们的绘画系统上绘制的布偶饼干怪兽。

不久，丹就成功地在Dynabook上部署了Smalltalk，并且在接下来的几个月里，它是唯一能在过渡版Dynabook上运行的软件系统。附录一收录了我当时撰写的“致谢”文档，其中对贡献者的分配以及相关的优先级划分很有意思。我投入的23万美元足够购买最初计划的30台机器中的15台（多年来，实际生产了大约2000台过渡版Dynabook）。正如叔本华所预言的那样，X主管现在认为过渡版Dynabook是个好主意，他想把除了两台以外的所有机器都留给自己的实验室（我在另一个实验室）。我不得不费尽周折才把我们的机器要回来，但最终成功了。

1. 万物皆为物
2. 物体之间通过发送和接收*消息*（以物体为单位）进行通信。
3. 物体拥有*自己的记忆*（就物体而言）。
4. 每个对象都是某个类的实例*（*而该类本身也必须是对象）。
5. 该类为其实例（以程序列表中的对象形式）保存共享*行为。*
6. 要执行程序列表，控制权会传递给第一个对象，其余对象则被视为其消息。

此时，Smalltalk 的大部分方案已被归纳为六个主要思想，这些思想与解释器设计的最初前提相符。前三个原则阐述了对象的“本质”——即如何从“外部”观察和使用它们。这些原则多年来无需任何修改。后三个原则——对象的内部运作——在每个版本的 Smalltalk（以及后续的面向对象编程设计）中都经过了调整。在这个方案中，(1 和 4) 意味着类是对象，并且它们必须是自身的实例。(6) 意味着类似 LISP 的通用语法，但接收对象是第一个元素，后面跟着消息。因此（下标表示为“○”，乘法表示为“*”）意味着：`ci <- de`

| 接收者 | \| 消息          |
| ------ | ---------------- |
| *c*    | *\| ○ i <- d\*e* |

c 绑定到接收对象，而整个消息就是发送给它的内容`○ i <- d*e`。该消息由字面标记“○”、一个在发送方上下文中待求值的表达式（在本例中为 i）、另一个字面标记 <- 以及一个在发送方上下文中待求值的表达式 (d*e) 组成。由于“LISP”对由两个元素对象构成，因此可以更简单地进行索引：`a` `c hd`、` `c tl`b`、`c` 和`c hd <- foo``d` 等。

*像a+b*和*3+4*这样的“简单”表达式，起初似乎更令人困惑。把它们理解为：真的有意义吗？

| 接收者 | \| 消息  |
| ------ | -------- |
| *a*   | *\| + b* |
| *3*    | *\| +4*  |

如果只考虑整数的话，这似乎很荒谬，但“+”还有许多其他比喻含义，例如：

![“小猫”|+“凯特”=>“小猫猫”[3 4 5 6 7 8\] |+ 4 = [7 8 9 10 11 12]](image/smalltalk/add.png)

这导致了一种为消息符号寻找*通用行为的*方法。“多态性”是官方术语（我认为源自 Strachey），但它并不完全贴切，因为它的最初含义仅适用于可以接受多种类型参数的函数。Smalltalk-72 中的对象类示例，例如 CONS 对的模型，如下所示：

[![CONS 对模型](image/smalltalk/conspairs.jpg)](https://worrydream-com.translate.goog/EarlyHistoryOfSmalltalk/Images/conspairs.png?_x_tr_sl=auto&_x_tr_tl=es&_x_tr_hl=en-US&_x_tr_pto=wapp)

由于在考虑消息的其余部分之前，控制权就已移交给类——类可以自行决定是否接收——因此可以保持完全的保护。Smalltalk-72 对象是“闪亮的”，不易受到攻击。环境的一部分是“消息传递对象”（一个通用的活动记录）中发送者的绑定，这允许接收者确定不同的权限（更多详情请参见附录 II）。这预示着 Smalltalk 最终将用作网络操作系统（参见 [Goldstein & Bobrow 1980]），但我记得在 Smalltalk-72 中并没有大量使用此功能。

Smalltalk-71 保留的风格之一是将函数和类的概念融合在一起。在其他作品中，Smalltalk-72 的类看起来像函数，也可以像函数一样使用，但使用 ISNEW 对象很容易生成实例（一种闭包）。因此，阶乘可以“外延地”写成：

*to fact n (^if :n=0 then 1 else n\*fact n-1)*

或者“有意地”，作为整数类的一部分：

*(... ○! » (^:n=1) » (1) (n-1)!)*

当然，Smalltalk（以及面向对象编程的总体思路）的核心思想就是用*意向性*定义一切。这也是我们学习这种新编程风格时的发展方向。我一直不太喜欢这种语法（括号和嵌套太多），我想要的是像 Smalltalk-71 那样更扁平、更符合语法规范的语法。右边是我当时一次演讲笔记中的一个语法示例。几年后，在 Dan 为 Smalltalk-76 设计的版本中，我们会看到更类似的语法。我认为 LISP 也经历了类似的过程——简洁实用的语法最终战胜了那些从未真正实现的奇思妙想。

建议的 Smalltalk-72 语法

```smalltalk
Pair :h :t 
   hd <- :h 
   hd » h 
   tl <- :t 
   tl » t 
   isPair » true 
   print » '( print. SELF mprint. 
   mprint » h print. if t isNil then ') print 
                                else if t isPair then t mprint 
                                else '● print. t print. ') print 
   length » 1 + if t isList then t length else 0
```

### Smalltalk-72 系统及应用开发

![首批“构建版”ALTO之一，早期Smalltalk Windows在过渡版Dynabook上运行，Turtles](image/smalltalk/firstbuildaltos.jpg)

在真正的机器上运行真正的 Smalltalk 语言，开启了一系列并行发展的浪潮，这些发展路径很难按照严格的历史顺序交织在一起。首先，我将概述 Smalltalk-72 系统从开发到过渡到 Smalltalk-76 的总体发展历程，然后讲述该项目最初动因而开展的、长达数年的儿童项目。在 Interim Dynabook 上运行的 Smalltalk-72 解释器速度并不算快（巴特勒称之为“雄伟壮丽”），但它易于修改，而且速度也足够快，足以构建许多实时交互式系统。

在编写完读取键盘并创建文本字符串的代码后，重叠窗口是我们（与 Diana Merry 合作）着手的第一个项目。Diana 构建了一个早期版本的位域块传输（bitblt），用于显示可变间距字体以及在显示屏上进行一般的书写。最初的窗口版本是真正的 2.5D 可拖动对象，但速度太慢，无法实际应用。我们决定等到 Steve Purcell 的动画系统完善后再进行改进，并选择了如今仍在使用的风格，这种风格更像是“2.25D”。窗口可能是 Smalltalk 中被重新设计和重新实现次数最多的类，因为我们当时的计算能力不足以像我以前在犹他州的同事在 Evans & Sutherland 的飞行模拟器项目中尝试的那样，持续地查看“世界坐标”并刷新。这是一个简单而强大的模型，但即使在 2.5D 中，也很难实时实现。 Smalltalk 中最早的实用窗口采用了 GRAIL 的敏感角点机制，用于移动、调整大小、克隆和关闭窗口。窗口调度使用了一个简单的“无循环”控制方案，将所有窗口串联起来执行。

在过渡版 Dynabook 上，接下来要实现的类之一（在数字、字符串等基础知识之后）是 Ted 实现的面向对象的 LOGO 海龟。它可以创建多个海龟实例，这些实例既可以用于绘图，也可以作为图形变换的参数。Dan 创建了一个“指挥官”海龟类，它可以控制一群海龟。不久之后，海龟又被设计成可以被窗口裁剪。

John Shoch 为 Smalltalk 代码开发了一个鼠标驱动的结构化编辑器。

![Findit检索示例、检索到的超文档、FM音色编辑器、OPUS乐谱捕获](image/smalltalk/findit.jpg)

当时在POLOS工作的Larry Tesler并不喜欢NLS的模式化和整体设计思路，他既想向NLS的前员工展示一种替代方案，也想进行一些用户研究（在当时几乎闻所未闻），了解编辑方面的情况。这促使他用Smalltalk编写了*miniMOUSE*，这是PARC第一个真正的所见即所得（WYSIWYG）编辑器。它几乎无需模式，而且使用起来非常有趣，不仅我们自己觉得好用，很多测试人员也都觉得好用（我当时负责拍摄视频，至今仍记得他们当时的喜悦和享受）。miniMOUSE*很快*成为Smalltalk代码的替代编辑器，我们做过的一些最精彩的演示都使用了它。

1974年春季，我在一个成人班上尝试了一个“小型程序”项目，那就是一个单页段落编辑器。结果发现它太复杂了，但我当时演示的示例完全没有使用任何模型（它是空中的），并成为了接下来几年Smalltalk文本工作的基础。大部分改进工作都是由Dan和Diana Merry完成的。当然，有了对象，就意味着可以创建多媒体文档，这几乎是唾手可得的。我们很早就意识到，在这样的文档中，每个组件对象都应该负责自己的编辑任务。Steve Weyer创建了一些最早的多媒体文档，之后Bob Flegal、Diana Merry、Larry Tesler、Tim Mott和Trygve Reenskaug等人又在多年间极大地扩展了多媒体文档的范围。

我和史蒂夫·韦耶共同开发了*Findit*，这是一个“示例检索”界面，它利用类与其实例之间的类比来构建检索请求。PARC 图书馆多年来一直使用 Findit 来控制图书流通。

我在 NOVA 上开发的采样合成音乐可以生成 3 个高质量的实时复音。Bob Shur 和 Chuck Thacker 将这套方案移植到 Interim Dynabook 上，实现了 12 个复音的实时合成。我们为低速设备（用于鼠标和键盘）设计的 256 位通用输入接口，使得连接另外 154 个输入接口变得非常容易，从而可以连接两个风琴键盘和一个脚踏板。滑音和衰减等效果也通过编程实现。Ted Kaehler 编写了 TWANG，一个音乐捕捉和编辑系统，它采用了我们设计的六线谱记谱法，旨在让孩子们也能理解音乐 [Kay 1977a]。采样技术难以实现的一点是压控振荡器 (VCO) 效果，这种效果在“平均律合成器”上很流行。一个夏天后，我们另一位才华横溢的暑期学生 Steve Saunders 接受了挑战，他需要在 ID 上找到一种方法，实现 John Chowning非常规的非实时 FM 合成。他必须找到一种与“FM”完全不同的思考方式，并且成功地将 8 个实时语音集成到 TWANG [Saunders *] 中。

![Shazam 标志性用户界面、PYGMALION 标志性编程、Simpula 医院模拟](image/smalltalk/shazam.jpg)

克里斯·杰弗斯（他是一位音乐家和教育家，而非计算机科学家）凭借OPUS——首个实时乐谱捕捉系统——让我们惊叹不已。与当今大多数系统不同，OPUS无需精准的节拍器演奏，而是首先通过寻找强弱拍（即乐句）来建立局部节奏波动模型，然后利用曲线拟合和外推法来判断特定音符在小节中的具体位置以及持续时间。

NOVA 上的动画以每秒 2-3 帧的速度运行 3-5 个物体。这个速度足以让*phi*现象生效（如果使用双缓冲），但我们想要的是“迪士尼式”的帧率，即每秒 10-15 帧，用于 10 个或更多大型物体以及更多小型物体。这项任务交给了才华横溢的史蒂夫·珀塞尔 (Steve Purcell)。到 1973 年秋季，他已经能够演示 80 个乒乓球和 10 匹飞马以每秒 10 帧的速度在 2.5D 空间中运行。他的下一个任务是将演示系统发展成一个通用系统，以便我们能够构建动画系统。他的 CHAOS 系统于 1974 年 5 月开始运行，正好赶上夏季访客罗恩·贝克 (Ron Baecker)、汤姆·霍斯利 (Tom Horseeley) 和专业动画师埃里克·马丁 (Eric Martin) 来访并构建 SHAZAM——一个功能强大且简单的动画系统，该系统基于罗恩在 60 年代末期在 TX-2 上完成的 GENESYS 论文项目 [Baecker 69]。

这段时间的主要毕业设计项目是戴夫·史密斯的 PYGMALION [Smith 75]，这是一篇关于示例编程的文章（不，我们并没有完全忘记）。它的编程方式是通过向系统展示如何进行修改，就像程序员在黑板上与其他程序员一起演示一样。这个程序成为了许多后续“示例编程”系统的起点。

我应该提一下这些程序的大小。PYGMALION 是用 Smalltalk-72 编写的最大的程序，代码大约有 20 页——正好能装进当时的 dynabook ALTO 笔记本里——史密斯的论文里有完整的代码。其他所有应用程序都比较小。例如，SHAZAM 动画系统在 1974 年夏天编写和修改了好几次，最终定稿成一个只有 5-6 页的应用程序，其中包含了图标控制的多窗口用户界面。

鉴于其源于仿真语言，我们很容易用几页纸就写出了 Simpula，它是 SIMULA 序列集调度方法的简化版本。那时我们已经决定，通过将各个方法调度为独立的仿真阶段，可以更清晰地呈现协程。SIMULA 的通用示例是一个作业车间。它可以推广到许多有用的形式，例如拥有服务于患者的资源部门的医院（见右图）。孩子们对医院不感兴趣，但他们发现可以用它来模拟游乐园（如迪士尼乐园）、他们的学校、他们和父母购物的商店等等。后来，这个模型构成了 Smalltalk Sim-kit 的基础，Smalltalk Sim-kit 是一个高级终端用户编程环境（详见下文）。

```smalltalk
(until Return or Delete do
    ('character <- display <- keyboard.
    character = ret » (Return)
    character = del » (Delete)
    )
then case
    Return: ('deal with this normal exit')
    Delete: ('handle the abnormal exit'))
```

在 Smalltalk-72 中，许多优秀的“计算机科学”结构都很容易实现。例如，当时的一个争议点是是否应该使用 goto 语句（我们最终没有使用），如果没有 goto 语句，那么如何定义一些非常有用的控制结构——例如循环的多个退出点？SLAC 的 Chuck Zahn 提出了一种*事件驱动的 case*结构，其中可以定义一组事件，当遇到某个事件时，循环就会退出，并且该事件会选择 case 代码块中的一个语句执行 [Zahn 1974, Knuth 1974]。假设我们要编写一个简单的循环，从键盘读取字符并将其输出到显示器。我们希望在按下 <return> 键时正常退出，在按下 <delete> 键时报错退出。附录 IV 展示了 John Shoch 如何定义这种控制结构。

### Smalltalk-72 的发展历程

Smalltalk-74（有时也称为 FastTalk）是 Smalltalk-72 的一个版本，它包含多项重大改进，例如提供了一个真正的“消息传递”对象、为类添加了消息字典（这是迈向真正类对象的一步）、由 Dan 重新设计并用微代码实现的 Diana Merry 的 bitblt（如今著名的位图图形二维图形运算符），以及一个更好、更通用的窗口界面。Dave Robson 在加州大学欧文分校就读期间听说了我们的项目，并尝试实现了一个相当不错的面向对象编程语言（OOPL）。我们邀请他来我们这里度过一个夏天，之后就再也没让他离开——他对 Smalltalk 官方语义的制定做出了巨大贡献。

最关键的改进是 OOZE（面向对象分区环境）虚拟内存系统，它服务于 Smalltalk-74，更重要的是，也服务于 Smalltalk-76 [Ing 78, Kae *]。ALTO 的体积并不大（128-256K），尤其是考虑到它的页面大小的显示屏（64K），即使是小型程序，我们也很快会遇到存储空间不足的问题。2.4 MB 的 Model 30 磁盘驱动器比软盘更快更大，但比现在的硬盘更慢更小。它与我曾在 FLEX 机器上尝试过的 HP 直接触式磁盘驱动器非常相似，当时我尝试过 B5000 段交换器的细粒度版本。尽管我有一些关于如何在清除数据时选择对象的好想法，但它并没有达到我的预期效果。当团队想要采用这个基本方案时，我说：“但我从来没让它正常工作过。” 我记得 Ted Kaehler 说：“别担心，我们会搞定的！”

所有这些系统的基本理念都是尽可能收集最全面的对象工作集。最简单的实现方式是交换单个对象。现在的问题在于，为了给需要的对象腾出空间，需要清除非工作集对象，这会产生额外的开销。（分页有时在这方面效果更好，因为每次磁盘操作可以获取多个对象（OOZE）。）有两个想法很有帮助。首先是巴特勒在 GENIE 操作系统中提出的见解：花费一小部分时间来清除脏对象，使核心尽可能干净，是值得的[Lampson 1966]。这样，崩溃的影响就不会那么大，而且总有干净的存储空间可以从磁盘上获取页面或对象。另一个想法来自 FLEX 系统，我在其中设置了一个随机决策机制（基于对象的类别），该机制在清除过程中决定是否丢弃某个对象。这有两个好处：重要的物品往往不会被移除，而且即使出现错误，也只会将其重新引入，因为分布情况保证了该物品很快再次被清除的概率很低。

另一个需要解决的问题是对象指针完整性（这也是我在FLEX机器上未能找到足够好的解决方案的地方）。真正需要的是一种完整的*事务处理，*一种全新的技术（可能是Butler想出来的？），它能确保无论系统何时崩溃都能恢复。这被称为“宇宙射线防护”，因为早期的ALTOS系统每天都会无缘无故地崩溃一两次。顺便说一句，这并没有特别困扰任何人，因为很容易就能找到*撤销*和*重放*机制来绕过这些“宇宙射线”。对于具有自动存储管理的基于指针的系统来说，这就有点棘手了。

Ted 和 Dan 决定使用驻留对象表 (ROT) 来控制存储，ROT 是查找对象机器地址的唯一位置。其他有用的信息也存储在 ROT 中，以辅助 LRU 老化算法。清除操作在后台进行：首先选择一个类，将磁盘定位到该类的实例（同一类的所有实例都存储在一起），然后遍历 ROT 查找存储中的脏对象并将其流式传输出去。这种方法非常高效，并且正如 Butler 所预见的那样，提供了一个相当大的干净存储空间，可以进行覆盖。然而，该设计（以及事务机制的实现）的关键在于他们提出的检查点方案。该方案确保无论何时发生崩溃，都会有一个不超过几秒钟的可恢复映像。OOZE 仅占用 80KB 的工作存储空间来交换对象，并且可以处理大约 65K 个对象（高达几兆字节，足以满足整个系统、其界面和应用程序的需求）。

### 面向对象风格

这里或许是阐述我们当时所理解的面向对象编程（OOP）风格与当时学术界刚刚开始研究的、被称为“抽象数据类型”的表面封装之间的区别的好时机。我们早期定义的“LISP-pair”就是一个抽象数据类型的例子，因为它保留了数据结构标志性的“字段访问”和“字段重绑定”。20世纪60年代的大量工作都致力于推广这类结构[DSP ]。“官方”计算机科学界开始将Simula视为定义抽象数据类型的一种可能工具（甚至其发明者之一[Dahl 1970]也持此观点），并且它构成了后来ADA（抽象数据类型协会）的大部分核心内容。这导致了数百篇论文中普遍出现的栈数据类型示例。坦白说，我们对此感到非常惊讶，因为在我们看来，Simula所暗示的远不止是简单地重新实现一个薄弱且临时性的想法。我从 Simula 中了解到，现在可以用*目标*来代替绑定和赋值。你最不希望程序员做的就是随意修改内部状态，即使是以比喻的方式呈现。相反，对象应该被呈现为更高层次行为的场所，更适合用作动态组件。

甚至我们教导孩子的方式（参见下文）也体现了这种看待对象的方式。毫不奇怪，这种方法对编程的难易程度、所需代码量、设计的完整性等等都有着显著的影响。令人遗憾的是，如今许多所谓的“面向对象编程”实际上只是用更花哨的结构包装的旧式编程。许多程序中充斥着“赋值式”操作，而这些操作现在却由更昂贵的附加过程来完成。

面向对象设计的特殊效率源自何处？这是一个很好的问题，因为它可以被视为将过程应用于数据结构的略微不同的方式。部分优势源于一种更清晰的复杂系统表示方法。在这里，约束与通用性同样重要。持久状态、多态性、实例化以及将方法作为对象的目标这四种技术的结合运用，构成了其强大功能的主要来源。这些技术本身并不要求使用“面向对象语言”——ALGOL 68 几乎可以实现这种风格——面向对象语言仅仅是引导设计者朝着一个富有成效的方向思考。然而，正确地进行封装不仅意味着对状态的抽象，更意味着从编程中消除面向状态的隐喻。

或许最重要的原则——同样源自操作系统架构——是：当你把一个数据结构交给别人时，你很少会希望他们拥有无限的权限。仅仅进行类型匹配远远不够。保护某些对象而保护其他对象也并非明智之举。应该将所有对象都视为一等公民，并加以保护。

我认为，优秀的面向对象编程（OOP）系统之所以体积更小，不仅仅是因为开发者被迫设计出更周全的方案。我认为这还与OOP带来的“每行代码的超高效率”密切相关。对象承载着丰富的意义和意图，其方法暗示了它能够执行的最强目标，其超类可以调用比大多数基于数据结构的过程更多的代码功能。赋值语句——即使是抽象赋值语句——表达的是非常底层的目标，而且为了完成任何操作，都需要大量的赋值语句。通常，我们不希望程序员去操作状态，无论状态是模拟的还是真实的。实例化对象的能力也会对代码体积产生显著影响。换个角度来看：虽然自动存储分配的后期绑定并没有实现程序员无法实现的功能，但它的存在使得代码更简洁、更强大。面向对象编程（OOP）在许多方面都是一种后期绑定策略，所有这些策略结合起来，比传统方法更能有效地避免系统脆弱性和规模爆炸。换句话说，人类程序员并非图灵机——他们的编程系统越少需要图灵机技术，就越好。

### 闲聊和孩子

![阿黛尔在乔丹中学发表讲话](image/smalltalk/turtle.jpg)

既然我已经总结了1976年之前Smalltalk上的“成人”活动（实际上我们当时只是半个成年人），现在让我回到1973年的夏天，那时我们准备开始和孩子们一起做实验。我们当中没有人知道如何与孩子们相处，但我们知道当时在斯坦福大学和帕特·萨普斯一起工作的阿黛尔·戈德堡和史蒂夫·韦耶在这方面做了很多工作，所以我们成功地说服他们加入我们。

由于我们当时完全不知道该如何教孩子（或者任何人）面向对象编程，Adele 最初的实验模仿了 LOGO 的海龟绘图，并且得到了看似非常相似的结果。也就是说，孩子们可以让海龟在屏幕上画图，但除了表面效果之外，似乎没有什么实质性的变化。那时我觉得，既然个人电脑的内容是交互式工具，那么这种新型创作素养的内容就应该是孩子们创造交互式*工具*。程序化的海龟绘图显然不是我想要的。

后来，Adele提出了一种教授Smalltalk作为面向对象语言的绝妙方法：《Joe Book》。我认为这部分受到了Minsky的观点的影响，即应该通过实际运行的严肃程序示例来全面地教授编程语言。

创建多个类框实例并发送消息，最终播放一个简单的多进程动画。在让孩子们猜测盒子可能是什么样子之后（他们有时猜得非常接近），会向他们展示：

```smalltalk
to box | x y size tilt
(○draw   »    (@place x y turn tilt. square size.
○undraw  »    (@ white. SELF draw. @black)
○turn    »    (SELF undraw. 'tilt <- tilt + :. SELF draw)
○grow    »    (SELF undraw. 'size <- size + :. SELF draw)
ISNEW    »    (SELF undraw. 'size <- size + :. SELF draw)
```

这个想法最棒的地方在于，孩子们可以用这些不起眼的盒子创造出无数的项目。其中一些最早的项目竟然是工具！这让我们兴奋不已。例如，12岁的玛丽安·戈尔丁（Marian Goldeen）的绘画系统就是一个功能齐全的工具。几年后，12岁的苏珊·哈梅特（Susan Hamet）的面向对象编程（OOP）插画系统也成为了一个工具（其设计与后来的MacDraw非常相似）。另外两个例子分别是15岁的布鲁斯·霍恩（Bruce Horn）的乐谱采集系统和15岁的史蒂夫·普茨（Steve Putz）的电路设计系统。现在回想起来，这或许可以算作计算机科学领域“早期成功综合症”的又一个例子。这些成功固然是实实在在的，但它们并不像我们想象的那样具有普遍性。它们的未来发展也远不如我们预期的那样强劲。这些孩子都来自帕洛阿尔托的学校（他们的背景并不典型），我们往往更容易被他们的成功所吸引，而忽略了他们遇到的困难。在某种程度上，我们看到的是“黑客现象”，即对于任何特定的追求，总有 5% 的人会自然而然地投身其中，而其余 80% 左右的人即使能够及时学习，也会觉得这完全不自然。

我们对此隐约有所察觉，但一直都取得了一些相对的成功。我们很清楚，学习这套系统的运作机制并非难事。孩子们只要围着ALTOS系统，拿着Adele的JOE绘本，就能掌握大部分内容。问题似乎更多地出在*设计上。*

![作者在过渡期间使用的 Dynabook 游戏室、Adele 的 Smalltalk 规划模板（上图）、孩子添加的新行为（下图）、Marian Goldeen 的绘画程序（上图）、Susan Hamel 的 OO Illustrator（下图）](image/smalltalk/author.jpg)

1974年春天，我给20位PARC的非程序员成年人教授Smalltalk之后，这件事开始让我深有体会。他们比孩子们更快地掌握了最初的内容，但就在眼看就要取得巨大成功的时候，他们却开始在一些在我看来并不比他们之前轻松搞定的问题上束手无策。其中一个问题是其中一位成年人提出的，他想做一个小型数据库系统，可以像卡片文件或旋转式名片夹一样使用。他们甚至连编程都做不到。我非常惊讶，因为我“知道”这样的项目远低于我们当时设定的“两页”的最终用户标准。那天晚上，我把程序写了出来，第二天又演示给他们所有人看。即便如此，他们中仍然没有人能独立完成。后来，我坐在房间里，反复琢磨着我讲课用的黑板。最后，我数了数这个小程序里有多少个不那么显而易见的思路。它们共有 17 个。其中一些就像建筑设计中的拱形概念一样：如果你之前不了解它们，就很难发现它们。

与读写能力的联系显而易见，令人痛心。仅仅学会读写是不够的。*文学作品*能够表达*思想。*语言被用来阅读和书写这些思想，但在某种程度上，思想的组织能力开始凌驾于单纯的语言能力之上。掌握一些深刻的思想对于更好地吸收更深刻的思想大有裨益[Papert 70s]。因此，我们决定教授*设计*。Adele为此想出了一个绝妙的办法。她认为，我们需要在关于问题的模糊想法和用Smalltalk运行程序所需的非常详细的编写和调试工作之间找到一个中间媒介。她把这个中间媒介称为*设计模板*。

利用这些工具，孩子们可以分析他们想要模拟的情境，并将其分解成类和消息，而无需担心方法的具体实现方式。方法规划可以用英语非正式地完成，这些笔记之后可以作为编写实际代码的注释和指南。这真是一个绝妙的想法，而且效果非常好。

但这还不足以让我们满意。正如阿黛尔喜欢指出的那样，如果只有部分孩子成功，而且这些成功还需要孩子和老师付出最大的努力才能实现，那么就很难称之为成功。真正的教育必须在不那么理想化的环境中运作，并且要更加稳健。尽管如此，一些成功与没有成功在本质上还是截然不同的。我们想要更多，于是开始推广“继承”的概念，希望它能让新手在只有专家才能设计的框架基础上进行构建。我们有充分的理由相信这种方法可行，因为我们对丽莎·范·斯通（Lisa van Stone）修改SHAZAM（一款由相对专业的成年人用Smalltalk编写的五六页动画工具）的能力印象深刻。然而不幸的是，继承——尽管是一种极其强大的技术——却被证明对新手（甚至专业人士）来说都非常难以掌握。

![史蒂夫·普茨（15岁）设计的电路系统，通过从屏幕顶部显示的“菜单”中选择形状来创建七巧板图案。该系统由一位14岁的女孩用Smalltalk实现Kay 77](https://worrydream.com/EarlyHistoryOfSmalltalk/Images/circuit.png)

现在，让我从今天的角度回顾一下。我现在基本确信，我们当初的设计模板方法最终还是不错的。只是我们没有长期坚持应用。我的意思是，现在有很多尝试教新手编程的成果积累起来[Soloway 1989]。这些尝试都讲述了类似的故事，似乎与所使用的编程语言的各种特性关系不大，而与新手难以像优秀程序员那样思考息息相关。即使我们现在拥有比那时（以及现在）好得多的界面，它也可能更像是写作，而不是我们预想的那样。也就是说，对于“ 80 %”的新手来说，他们需要花费数年时间逐步学习，才能构建出设计和解决方案前瞻所需的结构。$^{41}$

问题不在于如何让孩子们做事——他们喜欢动手，即使他们并不确定自己在做什么。这与早期语言学习的研究结果非常吻合，即无论是否涉及具体内容，孩子们都会进行大量的练习。动手*实践*似乎确实有效。难点在于如何确定应该向孩子传授哪些知识，以及这些知识应该在特定发展阶段深入到何种程度。尽管经过几个世纪的经验积累，这种困惑在自然语言的阅读和写作，以及数学学习中仍然存在。这也是儿童编程教学的主要障碍。何时、以何种顺序、以何种深度、以及如何教授这些重要的概念？

我们到底该不该尝试教授编程？过去三十年里，我接触过数百位程序员，却丝毫看不出编程对他们的思考能力或对人类知识的深刻理解有任何显著影响。恰恰相反，专家的知识往往根植于最初学习的环境之中——而大多数比喻性的延伸都会导致误导性的类比。相当多的艺术家、科学家、哲学家在专业领域之外都显得相当乏味（甚至在专业领域之内也可能如此）。我们需要警惕的第一种诱惑，就是那种声称有趣的追求与有趣的思想之间存在联系的说法。真正的音乐并不在钢琴里，即使从茱莉亚音乐学院毕业，也可能找不到或感受不到它。

我也遇到过一些人，对他们而言，计算机技术为思考人类的知识和影响力提供了一种重要的全新隐喻。但要实现真正的启蒙，除了计算机技术之外，还需要其他因素。

工具为获得启迪提供了一条路径、一个语境，几乎可以说是一种借口，但没有任何工具能够包含或提供启迪。切萨雷·帕韦塞曾说过：为了认识世界，我们必须建构它。换句话说，*我们创造并非仅仅为了拥有，而是为了认识。*然而，拥有本身可以发生在大部分认识尚未发生之时。

换个角度来看，知识在最初学习时是最不有趣的。表征——无论是标记、暗示还是物理控制——都会成为阻碍（几乎凌驾于目标之上），必须经过费力而痛苦的解读。从这里开始，有几条有用的路径，其中两条尤为重要且相互交织。

首先是*流畅性*，它部分源于构建心理结构的过程，在这个过程中，对表象的解读变得不再重要。句子中的字母和单词被体验为意义而非符号，网球拍或键盘成为身体的延伸，等等。如果继续深入，最终会成为某种专家——但如果没有其他领域的深厚知识，试图概括概括的结果通常过于生硬，不够完善。

第二种方法是将知识作为一种*隐喻*，以此来阐明其他领域。但如果缺乏流畅的运用，先前的知识很可能会占据主导地位，而这种隐喻也会变得模糊不清，甚至具有误导性。

我认为，博雅教育的精髓就在于此：在与他人建立联系的同时，掌握流利而深刻的知识。然而，我们的社会已经将目标降低到如此地步，以至于满足于“分数提升”，却不敢探究是否已经跨越了任何重要的门槛。能够读懂药瓶上的警告或写一篇关于暑假的文章并不等同于读写能力，我们的社会不应如此看待它们。例如，真正的读写能力是指能够流畅地阅读并理解潘恩《常识》中长达50页的论证，并且能够（并且乐于）流畅地撰写一篇评论或辩护文章。另一种20世纪的读写能力是，当听到一种新的致命传染病无法治愈时，能够立即意识到灾难性的指数级传播关系，并明白及早采取行动至关重要。还有一种读写能力，能够引导公民使用个人电脑，轻松流畅地构建疾病的系统模拟模型，并将其与更多信息进行比较。

在博雅教育层面，我们期望每一种能力之间的联系能够形成真正强大的隐喻，帮助我们从他人的角度思考问题。

因此，我们许多人希望孩子们能够深入、流畅地理解计算机的原因是，计算机就像文学、数学、科学、音乐和艺术一样，蕴含着特殊的思考方式，与其他知识和其他批判性思维方式相比，它能够增强我们理解世界的能力。

我们当时并不知道，而且很遗憾，15年后的今天，这些关键问题仍然没有真正有效的答案。但有一些迹象表明，即使是非常年幼的孩子也能理解和使用交互式*转换*工具。他们最先使用的就是自己的双手！他们可以轻松地将这些经验运用到计算机对象上，并对其进行修改。他们通常能够想象出某个修改会带来什么效果，并且对结果并不感到意外。两三岁的孩子可以使用类似 Smalltalk 的界面，并操作面向对象的图形。三年级的学生（几天之内）就能学会一个新系统的 50 多个功能——其中大部分是转换工具——包括其用户界面。他们可以回答任何只需要应用其中一个工具就能解答的问题。但是，对于需要两个或多个转换才能解答的问题，他们却极其困难。然而，他们应用一系列转换、向前探索却毫无问题。问题在于，他们几乎完全缺乏构思和实现哪怕是需要多次转换的简单目标的能力。

现在看来，我们需要学习和教授的是如何将变换以二或三为一组的方式进行组合，类似于学习跳棋这类策略游戏。“三步走”的模糊概念指向目标，可以为实现目标所需的更细致的工作奠定基础。这种技巧对大多数人来说都是可以掌握的，但对大多数人而言，需要数年时间逐步学习。

## V. 1976-80 年——第一个现代 Smalltalk 语言（-76），它的诞生、应用和改进

到 1975 年底，我感觉我们失去了平衡——“儿童版 Dynabook”的想法正在逐渐消退——或许是被专业需求压垮了。1976 年 1 月，我带领整个团队前往帕哈罗沙丘进行为期三天的非正式会议，旨在提出问题并重新调整方向。这次会议名为“让我们烧掉磁盘包”。会议期间没有发生争吵，团队成员彼此之间非常友好（我甚至可以说：彼此*热爱*），不会出现这种情况。但我们确实感到困扰。我引用了一句古老的格言：“任何生物都无法在自身的排泄物中生存”，以此呼吁我们*真正*重新开始：一个与 ALTO 和 Smalltalk 截然不同的软硬件系统。我们一致认为，当前 Smalltalk 的功能无法满足我们不同的期望。我认为我们需要一些不同的东西，因为我看不出面向对象编程本身如何能够解决我们最终用户的问题。其他人，特别是部分研究生，真心想要一个更优秀的 Smalltalk，速度更快，能够处理更复杂的问题。我想 Dan 也觉得，一个更优秀的 Smalltalk 可以成为我设想的那种系统的载体，但我当时无法清晰地描述这种系统。那次会议并没有以失败告终，我们回到 PARC 后依然是朋友和同事，但前四年那种绝对的默契再也没有重现。我开始设计一种新的小型机器和语言，我称之为 NoteTaker *，*而 Dan 则开始设计 Smalltalk-76。

我之所以想“烧毁磁盘包”，是因为我对媒介和环境有一种很麦克卢汉式的感受：用他的话说，一旦我们塑造了工具，它们就会反过来“重塑我们”。当然，如果工具确实好用，并且能够精准地解决相关问题，这当然是个好主意。但问题的另一面同样不容忽视——即使工具和环境本身存在缺陷，它们*仍然会*重塑我们的思维，部分原因在于我们希望范式能够指导我们的目标。像LISP和Smalltalk这样强大的范式如此具有吸引力，以至于它们会吞噬自身的发展：当你查看这两个系统中的应用程序时，你会发现它们与系统本身非常相似，而不是一种全新的理念。1975年我研究Smalltalk时，我看到的是一个很棒的东西，但我并没有看到一种面向终端用户的语言，也没有看到一个能够解决最初为儿童开发“读写”计算机媒介这一目标的方案。我当时想停下来，彻底推翻一切，从头开始。

NoteTaker 的*设计*初衷是打造一款“笔记本电脑”，利用当时几乎已经普及的 16K RAM（相比 ALTO 使用的 1K RAM 而言，这是一个巨大的进步），几年内就能实现。笔记本电脑无法使用鼠标（而且我本来就讨厌鼠标），平板电脑又显得笨拙（空间有限，而且触控笔松手后容易滑落），所以我设计了一种嵌入式指点设备，称之为“tabmouse”。它是一种相对指针，带有*向上*传感器，可以像鼠标一样滑动，并且能够保持在你离开的位置，但它的手感更像触控笔，并且采用了一种缩放仪机制，消除了鼠标在 x 和 y 方向上恼人的滞后偏差，从而避免了鼠标难以用作笔的弊端。我计划采用最初为 Dynabook 设计的、由低速但高度集成的芯片组成的多处理器架构，并且需要一种新的字节码解释器，以构建一个比 Smalltalk-72 更友好、更简单的系统。

![笔记员](image/smalltalk/notetaker.jpg)

与此同时，丹正在推进他对 Smalltalk 的全面改造，思路与此类似（1978 年）。首要任务是摒弃函数/类二元论，转而采用完全内涵式的定义，将每一段代码都视为一个内在方法。我们从一开始就希望如此（而且大部分代码已经这样编写了）。我和阿黛尔、当时正在开发桌面出版的拉里·泰斯勒以及研究生们都强烈希望引入真正的继承机制。丹必须找到一种比 Simula 僵化的编译时概念更好的方法。是时候真正落实“一切皆对象”的理念了，这其中也包括所有内部“系统”对象，例如“活动记录”等等。我们一致认为，早期 Smalltalk 的灵活语法过于灵活，这种程度的可扩展性并不理想。我们喜欢的所有扩展都使用了不同的关键字方案，因此 Dan 设计了一种关键字/运算符组合语法，这种语法非常灵活，同时又能确保人类和机器都能清晰地理解。这使得我们可以定义一个类似 FLEX 机器的字节码编译器和一个高效的解释器，其运行速度比之前的直接解释器快 180 倍。OOZE VM 系统可以进行修改以处理这些新对象，并且其容量与 ALTO 的内存和磁盘完美匹配。

### 遗产

关于继承，我想简单提一下。Simula-I 既没有类作为对象，也没有继承。Simula-67 添加了继承，作为对 ALGOL-60 <block> 结构的泛化。这的确是个好主意。但它也存在一些缺点：一些小问题，例如多线程列表中的名称冲突（现在几乎没人用线程列表了）；以及一些大问题，例如扩展类型结构的僵化、需要限定类型、只有一条继承路径，以及难以适应具有增量编译和其他即时更改需求的交互式开发系统。此外，还有许多超出 Simula 目标范围的问题：这些问题与人工智能领域中各种建模和推理方式有关。例如，并非所有有用的问题都能通过遵循静态链来解答。有些问题需要通过动态绑定的“部分”（即实例变量）来实现某种“继承”或“推理”。多重继承看起来也很重要，但不同超类中同名方法之间可能出现的冲突似乎难以处理，等等。

另一方面，由于动态语言可以实现静态编译语言难以完成的任务，我决定在 Smalltalk-72 中省略继承这一特性，因为我们可以利用 Smalltalk 类似 LISP 的灵活性来模拟继承。这些人工智能理念的最大贡献者是 Larry Tesler，他在早期桌面出版系统的各种版本中广泛使用了现在被称为“槽继承”的技术。如今，这会被称为“委托式”继承方案 [Liberman 84]。在此期间，Danny Bobrow 和 Terry Winograd 设计了一种名为 KRL 的“基于框架”的人工智能语言，它是“面向对象的”，我认为它受到了早期 Smalltalk 的影响。它有一种称为“视角”（specialship）的多重继承*机制*，允许一个对象以非常清晰的方式扮演多个角色。几年后，Ira Goldstein 和 Bobrow 将许多此类理念融入了 PIE，PIE 是 Smalltalk 的一个有趣的扩展，用于网络和更高级别的描述 [Goldstein & Bobrow 1980]。

到了 Smalltalk-76 出现的时候，Dan Ingalls 已经提出了一种语义上类似 Simula 的方案，但可以根据我们紧密交互的目标进行动态的增量式修改。我当时并不完全满意，因为我觉得我们需要一个更好的继承理论（现在仍然需要）。例如，继承和实例化（实例化也是一种继承）混淆了实用性（例如为了节省空间而对代码进行重构）和语义（用于太多任务，例如：特化、泛化、物种形成等等）。Alan Borning 在 Thinglab [Borning 1977] 中采用了一种多重继承方案，并在 Smalltalk-76 中实现了该方案。但是，当时并没有出现一个全面而清晰的多重继承方案，能够超越 Dan 最初的类似 Simula 的设计。

与此同时，与施乐公司的竞争仍在继续。当时大约有500台ALTO计算机通过以太网相互连接，并连接到激光打印机和文件服务器，这些服务器都使用ALTO作为控制器。我给施乐公司的规划人员写了很多备忘录，试图让他们将个人计算作为其主要发展方向之一。以下是一个例子：

#### 对未来的简单愿景

*关于我1971年彭德里论文的简要更新*

到了20世纪90年代，个人电脑将会有数百万台。它们的大小和今天的笔记本电脑差不多，配备高分辨率的平面反射式显示屏，重量不到10磅，计算和存储容量却是Alto的10到20倍*。*我们不妨称它们为*“Dynabook”。*

购买价格将与当时的彩色电视机价格相仿，不过大多数机器将由制造商免费赠送，他们推销的是个人计算的内容，而不是机器本身。

...

尽管*Dynabook*将拥有相当大的本地存储空间，并且大部分计算工作都将在本地完成，但它的大部分时间仍将连接到各种大型全球信息平台，以便与其他机构交流想法、数据、工作模型，以及进行组织日常运作所需的沟通。通信链路将通过专用线路、公共线路和分组无线电进行传输。Dynabook 还将作为信息平台的服务器使用。它们将拥有足够的性能，完全由软件控制。

#### 这一愿景的主要要点

- 只需要几种硬件类型就能处理系统几乎所有的处理活动。
- 个人电脑、通信链路和信息工具是施乐未来发展的三大关键组成部分。

...

换句话说，计算机系统的*物质部分*是计算机本身，所有内容和*功能**都是*用软件实现的。

由此可以得出两条重要的指导原则：

- 材料：如果计算机硬件材料的设计和开发能够像施乐公司开发特殊感光合金那样细致完善，那么只需要设计一到两种计算机即可……在此领域额外的研发投入将通过简化制造工艺和提高产量来降低成本而获得巨大的回报。
- 内容：除了能够利用相同的素材不断创造新内容这一极佳的通用性之外，*软件*还具有三个重要特征：
  - 内容功能的复制时间和成本*为零*。
  - 内容功能的开发时间和成本都很高*。*
  - 内容功能的变更时间和成本可能很低*。*

如果施乐公司想要在新兴的信息媒体业务领域生存并发展壮大，就必须认真对待以下几点。如果能够做到这一点，该公司将拥有极佳的成功机会，原因有以下几点：

- 施乐公司拥有足够的财力来支付少量功能强大的计算机型号和大量软件功能的巨额开发成本。
- 施乐拥有强大的市场基础，能够大规模销售这些功能，从而获得巨额利润。
- 施乐公司拥有数量惊人的全球顶尖软件设计师。

1976年，查克·萨克设计了ALTO III，这款电脑将采用新型16K芯片，并能放置在桌面上。它的售价与那些笨重的大型专用“文字处理器”相仿，但功能却强大得多。然而，1976年8月，施乐公司做出了一个影响深远的决定：不将ALTO III推向市场。这对我们许多人来说都是一个巨大的打击——甚至包括我，我一直都把ALTO视为通往“真正产品”的垫脚石。1992年，个人电脑和工作站的全球市场规模达到了9000万美元——是大型机和小型机市场的两倍，更是施乐公司1992年总收入的数倍。而这个时代最成功的公司——微软——并非硬件公司，而是一家软件公司。

### Smalltalk 用户界面

一些审稿人要求我详细介绍一下“Smalltalk风格”重叠窗口用户界面的发展历程，因为现在全球已有超过2000万台计算机使用其衍生版本。要写出一部像样的历史，篇幅恐怕就跟这章一样长，而且目前还没有人写过。[Kay 89]中对一些概念做了总结——我再补充几点。

Smalltalk用户界面最终使用的所有元素，早在六十年代就已经出现——它们是访问和调用交互式系统功能的各种方式。当时的两大思想中心是林肯实验室和兰德公司——它们都获得了美国高级研究计划署（ARPA）的资助。这些思想最终汇聚成一套强大的理论和经久不衰的案例，这主要归功于LRG（学习研究小组）将研究重点放在儿童身上。因此，我们开始将学习视为我们希望实现的主要目标之一。早期，这促使用户界面的目的发生了90度的转变，从“访问功能”转变为“用户在实践中学习的环境”。这种新的立场能够回应蒙特梭利和杜威的教育理念，尤其是前者的理念。在重读杰罗姆·布鲁纳的著作后，我开始思考超越儿童课程的范畴，构建“用户界面课程”。

LRG 的具体目标是找到一种与写作等效的方式——即在某种媒介中边做边学、边思考——我们新的“口袋宇宙”。出于种种原因，我最终选择了“图标式编程”来实现这一目标，借鉴了六十年代许多 ARPA 项目中使用的图标式表现形式。我的朋友尼古拉斯·尼葛洛庞帝是一位建筑师，他对环境如何影响人们的工作和创造力非常感兴趣。他致力于将新的计算机技术融入人们熟悉的环境中。我过去有过不少戏剧表演经验，记得柯勒律治的一句格言：“人们去看‘糟糕的戏剧’是为了忘记，去看‘好的戏剧’是*为了记住*。”换句话说，戏剧之所以成功，在于它能够唤起观众自身的智慧和经验。

[![保罗·罗夫纳展示标志性的“林肯魔杖”，约摄于1968年](image/smalltalk/paulrovner.jpg)]![最后一个 Smalltalk-72 界面，Ted Kaehler 的标志性绘画界面](image/smalltalk/lastsmalltalk72.jpg)

综上所述，我们想要一个看似自由的环境，在这个环境中，探索会促成预期的序列发生（蒙特梭利）；一个允许动觉、图像和符号学习的环境——“用图像做事*，就能产生*符号”（皮亚杰和布鲁纳）；一个用户永远不会被困在某种模式中的环境（GRAIL）；一个蕴含着熟悉感的环境（尼葛洛庞帝）；以及一个能够放大用户自身智慧的环境（柯勒律治）。如果说，在阐明这些理念之后，我们就能直接着手设计出如今我们所熟知的界面，那将是一个完美的结局。事实上，用户界面设计工作是在编写 Smalltalk 程序、设计儿童实验、尝试理解图像结构以及各种尝试之间断断续续地进行的。尽管如此，这种迂回曲折的环境几乎迫使我们最终呈现出一个优秀的设计。当时 PARC 的几乎每个人都对用户界面发表了自己的看法，既有我们自己的，也有他们自己的。我们无法一一列举数百个想法和讨论的具体内容。然而，最终的整合无疑要归功于 Dan Ingalls，他认真倾听每个人的意见，贡献原创想法，并不断构建用户测试的设计方案。我参与了很多工作，例如设定场景、设计重叠窗口等等，Adele 和我设计了大部分实验。此外，Ted Kaehler 和访客 Ron Baecker 也做出了非常宝贵的贡献。[Dan Halbert] 设计了 SmallStar，这是 Xerox Star 产品的标志性原型界面。

与此同时，我成功地让道格·费尔贝恩对*Notetaker*产生了兴趣。他设计了一种出色的“智能总线”，可以高效地处理多个低速处理器，这套系统看起来非常有前景，尽管PARC的大多数人都认为我放弃ALTO的高速双极型硬件简直是疯了。但我当时觉得双极型硬件永远不可能应用到笔记本电脑或Dynabook上。另一方面，我讨厌当时刚刚出现的8位微处理器，因为它们的设计既愚蠢又幼稚——丝毫看不出有任何软件设计师参与其中。

### Smalltalk-76

![Smalltalk-76](image/smalltalk/smalltalk76.jpg)

Dan 于 11 月完成了 Smalltalk-76 的设计，他和 Dave Robson、Ted Kaehler 以及 Diana Merry 仅用了七个月的时间就成功地从零开始实现了这个系统（包括重写所有现有的类定义）。这真是一项了不起的成就，尽管我当时很想推倒重来，但我仍然感到无比震撼。它运行速度快、响应迅速，能够处理“大型”问题，而且非常有趣。该系统由大约 50 个类组成，源代码约 180 页。这其中包括所有操作系统功能、文件、打印和其他以太网服务、窗口界面、编辑器、图形和绘制系统，以及 Larry Tesler 的两项新贡献：用于在继承层次结构中查看静态方法的著名浏览器和用于在运行时环境中调试的动态上下文。从各个方面来看，它都是将我们对 Smalltalk 的所有想法和渴望整合到一个统一的软件包中的体现。此后所有的 Smalltalk 版本都与这个理念非常相似。在许多方面，正如 Tony Hoare 曾经评价 Algol 时所说的那样，Dan 的 Smalltalk-76 比它的后继者有了很大的改进！

以下是 Dan 编写的两套风格独特的 ST-76 课程。

![两款时尚的ST-76级](image/smalltalk/st76.jpg)

请注意，尤其是在 Window 类中，代码是如何以目标的形式表达的，这些目标需要其他对象（或自身）来实现。父类 Window 的主要任务是感知事件并将其作为消息分发给子类。在本例中，文档窗口（DocWindow 的子类）将处理用户交互的影响。Window 类会感知到键盘处于活动状态，并向自身发送一条消息，该消息将被子类方法拦截。如果没有找到相应的方法，输入的字符将被丢弃，窗口会闪烁。在这种情况下，它找到了 DocWindow 的 `keyboard`方法，该方法会通知当前文档窗口检查输入的字符。

![Smalltalk 的主要实现者、Smalltalk-76 的创建者 Dan Ingalls 及其实现计划（如下）；Jack Goldman 终于使用了他多年来一直付费的系统（Alan Borning 也提供了帮助）；施乐公司高管使用 SimKit 进行了最终用户模拟。总时长（含培训）：3 小时](image/smalltalk/daningalls.jpg)

1978 年 1 月，Smalltalk-76 迎来了它的第一次真正考验。CSL 邀请了施乐公司的十位高管到帕克研究中心 (PARC) 参加为期两天的软件研讨会，重点讨论软件的复杂性及其应对方法。LRG 受邀为他们提供终端用户编程的实践体验，以便“让他们在两个半小时的课程中‘做一些实际的事情’”。我们立即决定不教他们 Smalltalk-76（我之前提到的“刻录磁盘包”的观点完全正确），而是用 Smalltalk-76 在两个月内创建一个功能丰富的系统，专门为非专业成年用户量身定制（丹的观点更胜一筹）。我们以“Simpula”作业车间仿真模型为起点，决定为一个通用的作业车间仿真工具构建用户界面，高管们可以将其转化为特定的动态仿真，并通过屏幕上的动画图形来展现其不断变化的状态。我们将其命名为 Smalltalk SimKit。这是大家齐心协力、竭尽全力完成的。尽管刚生完宝宝不久，Adele 还是成为了设计负责人。我至今仍清晰地记得她一边给 Rachell 喂奶，一边埋头调试 SimKit 的场景。

有很多有趣的问题需要解决。系统本身很简单，但必须与 Smalltalk 完全隔离，尤其是在错误信息方面。Dave Robson 设计了一个巧妙的方案（几乎是一个专家系统），用于捕获 Smalltalk 内部的错误信息，并将其转换为有意义的 SimKit 术语。用户界面方面有很多细节需要处理——有些很日常，例如创建只能查看四个 SimKit 类（Station、Worker、Job 和 Report）的新浏览器；有些则更令人惊讶，例如我们让十位年龄相仿的 PARC 非技术成年人试用，发现他们很难看清屏幕上的内容。我们这些三十多岁的人习惯的小字体，对五十多岁的人来说却很不方便。这促使我们设计了一个不错的系统介绍方式：鼓励高管们通过选择不同的字体和大小来自定义屏幕，而这样做的一个意外收获是，他们学会了如何自然地使用鼠标。

在“大日子”当天早上，泰德·凯勒决定对虚拟内存系统OOZE进行一些改动，以提升其运行速度。我们都屏住了呼吸，但由于设计清晰明了，实施人员信心十足，改动果然奏效，高管们的实践操作也取得了巨大的成功。第一节课进行到大约一个小时时，一位副总裁（他15年前曾用FORTRAN编写过一些程序）终于意识到自己正在编程，不禁感叹道：“原来最终还是到了这一步。”十位高管中有九位完成了与各自兴趣相关的模拟问题。其中一个最有趣、最复杂的问题是由施乐旗下某公司的负责人完成的，他利用实际数据（他记在脑子里）构建了一个模型，该模型无法用封闭形式的数学方法轻松求解——它揭示了考虑到生产线平均缺陷概率，工人配置方面存在的一个严重缺陷。

![Alan Borning 的 Thinglab，一个基于约束的图标式问题求解器；Larry Tesler 设计和构建的 Smalltalk-76 分层类浏览器；作者为 ST-76 开发的基于笔的界面。](image/smalltalk/thinglab.jpg)

当时完成的另一个重要系统是艾伦·博宁的 Thinglab [Borning 1979]——这是首次认真尝试超越伊万·萨瑟兰的 Sketchpad。艾伦设计了一种非常好的方法来处理约束，这种方法不需要求解器是全知的（或者能够解决费马大定理）。

我们可以看到，Smalltalk 的“推送”式机制最终可以被“拉取”式机制所取代，后者由不同方法所基于的值的变化驱动。这虽然是一个老生常谈的想法，但 Thinglab 展示了如何利用面向对象定义来自动限制事件驱动处理的上下文。我们很快发现，“原型”比类更易于管理，而且如果方法类能够大致了解其功能（灵感来自 Pat Winston 的二阶模型），那么多重继承就能得到很好的支持。

与此同时，*NoteTaker*变得越来越逼真、体积越来越大、速度也越来越慢。此时，我原本希望使用的西部数据模拟芯片已经显露出“扩散型产品”的迹象，看起来不太可能真正面世。我们开始四处寻找可靠的替代方案，即使它的架构并不完美。1978 年，最佳选择是英特尔 8086，这是一款 16 位芯片（虽然它带有许多 8008 和 8080 的遗留缺陷），但其性能勉强够用——我们需要三块 8086 来弥补 ALTO 的不足，一块用于解释器，一块用于位图图形，一块用于 I/O（网络等）。

*丹一直对NoteTaker*很感兴趣，他想看看能否用 Smalltalk-76 开发一个*NoteTaker*系统。为了实现这一点，它必须运行在 256K 内存中，这是我们为这台机器规划的最大内存容量。ALTO 上类似 NOVA 的模拟“机器代码”无法移植过来，而且它还必须能够装进内存——因为只有软盘，没有内存交换。这一挑战促使我们对系统设计进行了一些卓越的改进。我们使用了 Ted Kaehler 的系统跟踪器（它可以从旧的虚拟内存写入新的虚拟内存）将 Smalltalk-76 克隆到 NoteTaker 中*。*索引对象表（早期 Smalltalk-80 中使用的那种）首次出现在这里，以简化对象访问。我们还尝试了一种连续堆叠上下文的方法：以节省空间并提高速度。大部分旧机器代码都用 Smalltalk 重写，整个机器内核减少到 6K 字节的（不太强大的）8086 代码。

所有的重新设计都产生了有趣的效果。虽然 8086 在位字节流处理方面不如 ALTO（而且之前用于辅助图形的许多机器代码现在都用 Smalltalk 编写了），但其整体解释器的速度大约是 ALTO 版本的两倍（因为 ALTO 的 4KB 微代码内存无法容纳所有 Smalltalk 字节码解释器）。通过各种技巧和调整，图形显示方面的问题得到了“很大程度的弥补”（用 Dan 的话说）。这主要是因为 ALTO 的微代码内存不足以容纳所有的 Smalltalk 模拟代码——其中一些必须用模拟的“NOVA”代码渲染，这就导致了两层解释。事实上，Notetaker 的*运行*效果非常好，尽管它的性能足以碾压任何一台笔记本电脑。它又回到了桌子上，看起来很像 miniCOM（以及几年后出现的几款计算机）。它确实可以使用电池供电，我们中的几个人有幸带着*NoteTaker*上飞机，在 35,000 英尺的高空运行一个带有窗口界面的面向对象的系统。

![NoteTaker界面设计[Ka 79\]，史蒂夫·乔布斯的视角，Trygive Reeskaug对复杂结构的多视图（上图），Bob Flegal和Dlana Merry的多媒体文档（下图）](https://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/designfornotetaker.jpg)

我们最终制造了大约10台这样的机器，虽然从很多方面来看，这在工程上都是成功的，但为了制造它们而不得不采取的措施，再次将最初的目标用户群体排除在外。如果施乐公司（以及帕克研究中心）当时对这些小规模的想法抱有信心，我们本可以投入更多资源来支持这些设想，并在上世纪70年代这些技术首次具备应用潜力的时候就成功地将它们制造出来。由于公司缺乏足够的意愿来利用内部技术专长，我们不得不从英特尔采购错误的CPU，从惠普采购错误的显示器，这令人无比失望。

那时已是1979年，我们又一次进行演示，但这次的听众非常感兴趣：史蒂夫·乔布斯、杰夫·拉斯金以及苹果公司的其他技术人员。他们启动了一个名为*Lisa的*项目，但还不太确定它应该是什么样子，直到杰夫对史蒂夫说：“你真应该来PARC看看他们在做什么。”就这样，在重叠窗口技术发明八年多之后，在ALTO计算机开始运行六年多之后，那些真正能够将这些想法付诸实践的人，终于有机会亲眼目睹了它们的成果。我们使用的机器是Dorado，它是ALTO的“大哥”，速度非常快，其Smalltalk微代码主要由布鲁斯·霍恩编写，他是我们最初的“Smalltalk小子”之一，当时还只是个十几岁的少年。拉里·泰斯勒负责演示的主要部分，丹坐在副驾驶座上，我和阿黛尔则在后座观看。演示中最精彩的部分之一是史蒂夫·乔布斯说他不喜欢我们当时使用的双向滚动方式，问我们能否实现平滑连续的滚动。不到一分钟，丹就找到了相关方法，进行了（相对较大的）修改，滚动就实现了连续滚动！这让参观者们大吃一惊，尤其是那些程序员，因为他们从未见过如此强大的增量式滚动系统。

史蒂夫曾试图从施乐公司（苹果公司的少数风险投资家之一）获得或购买这项技术，但施乐公司既不愿放弃这项技术，也不愿提供资源，通过资助开发更好的*NoteTaker*和 Smalltalk 来继续在内部开发这项技术。

## VI. 1980-83 年——Smalltalk 的发布版本（-80）

“艺术中最大的罪过并非如人们通常认为的那样是乏味，而是比例失调。”——保罗·欣德米特

正如丹所说，“停止*NoteTaker*项目的决定促使我们更广泛地发布Smalltalk。” 但对我来说并非如此。那时，我既为丹和其他人实现的Smalltalk概念的简洁和优雅而感到高兴，又为它与孩子们之间的距离越来越远而感到难过——令我震惊的是，自Smalltalk-76问世以来，竟然没有一个孩子用Smalltalk编程过。施乐（以及PARC）现在专注于“工作站”本身——但我仍然想要“游戏机”。Dynabook的浪漫似乎越来越遥不可及，讽刺的是，就在各种所需技术开始具备商业可行性的时候——其中一些技术，例如平板显示器，不幸的是，被发明它们的美国公司拱手让给了日本人。这真是“功亏一篑”的典型案例。拉里·泰斯勒认定施乐永远不会“明白”，于是在1980年5月被史蒂夫·乔布斯聘为Lisa的主要*设计师*。我同意了，我正好有学术休假，就休假了。

阿黛尔决定主导新版 Smalltalk 的文档编写和发布流程，使其能够广泛分发，几乎不受目标硬件的限制。只需对 NoteTaker Smalltalk-78 进行少量修改，即可使其成为一个可发布的系统。或许最具讽刺意味的改动是将那些使 Smalltalk 更易读的自定义字体（也是整个 PARC 文化的标志）改回标准的普通 ASCII 字符。据彼得·德意志 (Peter Deutsch) 所说，此举“当时在团队内部遭到了强烈反对，但事实证明，这对系统被世界接受至关重要。” 另一个改动是将代码块做得更像 lambda 表达式，正如彼得·德意志九年后所指出的那样：“回想起来，这种不同类型实例化和作用域的激增可能是一个糟糕的想法。” 最令人费解的奇怪想法——至少对我这个新来的外行来说——是引入元类（实际上只是为了让实例初始化更容易一些——相比 Smalltalk-76 已经相当合理的做法，这只是一个很小的改进）。 Peter 在 1989 年的评论很有代表性，也很有道理：“元类对很多用户来说都令人困惑，而且从整体上看，它可能弊大于利。” 事实上，在他们的 PIE 系统中，Goldstein 和 Bobrow 已经在 Smalltalk 中实现了一种“观察者语言”，这在某种程度上遵循了我一直倡导的面向视图的方法，并且在某些方面类似于 KRL 中提出的“视角”[Goldstein *]。一旦可以通过多个视角观察一个实例，即使是像 Class Class 和 Class Object 这样的“半元类”也并非真正必要，因为对象角色和类的实例角色只是不同的视角，而且很容易处理包括实例化在内的生命周期问题。这（以及其他一些好想法）本来唾手可得，但却没有被采纳。我猜测 Smalltalk 已经进入了我故事开头提到的最后一个阶段，在这个阶段，一种做事方式最终被奉为圭臬，成为一种僵化的信念体系。

### 结尾

最后补充一点。硬件本质上就是软件的早期结晶。它的存在是为了让程序方案尽可能高效地运行。然而，硬件常常被视为理所当然，而让软件设计者看起来合理则成了他们的任务。这导致底层技术和过度优化阻碍了程序设计的进步。正如鲍勃·巴顿曾经说过的那样：“系统程序员就像是低级教派的高级祭司。”

理解软件发展的一种方式是，它很大程度上是寻找*后期绑定*方法，然后游说制造商将这些理念集成到硬件中。早期的硬件程序和参数是绑定在一起的；随机存取存储器（RAM）就是一种后期绑定方案。循环和索引过去是通过修改存储器中的地址来实现的；索引寄存器也是一种后期绑定方法。多年来，软件设计人员找到了后期绑定计算位置的方法——这催生了基址/边界寄存器、段重定位、页内存管理单元（MMU）、迁移进程等等。分时技术因为“效率低下”而被搁置多年——但制造商不愿在机器上安装MMU，大学不得不自行实现！递归将参数后期绑定到过程，但即使是最基本的堆栈机制也花了数年时间才被集成到CPU中。大多数机器仍然不支持动态分配和垃圾回收等机制。简而言之，如今大多数硬件设计只是对过时架构的重新优化。

从后期绑定角度来看，面向对象编程（OOP）可以被视为一种尽可能全面地实现后期绑定的技术：行为集合中状态和过程的混合、它们的位置、调用方式、调用时间和原因、使用的硬件等等，以及更微妙的，OOP方案本身所使用的策略。包装的艺术就是陷阱的艺术。

为了完全封装对象，必须高效处理以下两种情况。如果a和b被绑定到例如 ALU 可以处理的形式的“3”和“4”，而a + b却因此产生任何开销，那将是极其糟糕的。这些操作应该使用旁路逻辑（最简单的方案就是一个与门）来捕获操作数是否与 ALU 不兼容的情况，从而实现全速执行。现在，所有必须快速执行的基本操作都已封装完毕，而不会降低机器速度。

第二种情况发生在陷阱判定目标对象对于算术逻辑单元（ALU）而言过于复杂时。此时，硬件必须动态地找到一个能够处理这些对象的方法。这与索引非常相似——其中一个对象的类通过所需的方法选择器以更通用的方式进行“索引”。换句话说，方法的虚拟地址是<类><选择器>。由于目前大多数硬件都会进行某种形式的虚拟地址转换来找到实际地址（即陷阱），因此完全可以将面向对象编程（OOP）分派的开销隐藏在已经合理化的内存管理单元（MMU）开销中。

再次强调，面向对象编程的核心在于无需关注对象内部的具体实现。在不同机器上用不同语言编写的对象*应该*能够相互通信——而且将来也必须如此。这里的“后期绑定”指的是将不兼容性捕获到re兼容性方法中——[Popek 1984] 对其中一些问题进行了很好的讨论。

沿用“后期绑定”这个比喻，我们还能期待看到哪些其他的后期绑定方案呢？目前正在试验的优秀后期绑定方案之一是施乐帕克研究中心（Xerox PARC）的*元对象协议*项目[Kiczales 1991]。其核心思想是，语言设计者为实例、变量等内部表示所选择的方式可能无法满足实现者的需求，因此在固定的语义框架内，他们允许实现者为系统提供策略——例如，使用哈希查找来查找实例中的槽位，而不是直接索引。这些策略随后会被高效编译，并扩展系统的基础实现。这直接继承了Simula、FLEX、CDL、Smalltalk和Actors等早期类似方向的理念。

另一个已经必不可少的后期绑定方案是，当一个新对象出现在对象系统中时，避免直接进行协议匹配。换句话说，如果有人从地球另一端寄给你一个对象，如果它符合你本地的协议，那就很不寻常了。将来，让对象携带更多关于自身的信息会更容易——信息量足以让你“理解”它的规范，并通过更微妙的推理匹配将其配置整合到你的系统*中*。

超越我们今天所知的面向对象编程（OOP）的视角，还可以通过思考后期绑定来实现。Prolog 的精妙之处在于，它无需绑定到值即可执行计算 [Col ]。变量本身就是一个对象，可以构建一个包含部分结果的网络，待最终找到绑定时再进行填充。Eurisko [Lenat ] 在尝试解决问题的过程中构建方法并修改其基本策略。不是问题寻找方法，而是方法寻找问题——Eurisko 寻找方法的方法。这被称为“机会主义编程”——我认为它是一种追求更高境界的驱动力，在这个过程中，问题得以解决。

未来五年，随着普适网络这一范式转变的到来，这种更高的计算精细度将变得至关重要。对象将逐渐成为主动主体，在网络中穿梭，为其管理者寻找有用的信息和工具。从世界另一端带回计算环境的对象，将无法像现在这样通过直接协议匹配进行自我配置。相反，这些对象将携带更多关于自身的信息，并以允许*推理*对接的形式呈现。一些正在进行的规范制定工作可以应用于这项任务[Guttag][Goguen]。

我曾半开玩笑地把编程语言的发展比作“太阳黑子”理论，认为大约每11年就会出现一次重大进步。我们从1950年的机器代码开始，然后在1956年出现了FORTRAN，它被视为一种“更好的旧事物”，如果把它看作是一种“几乎全新的事物”，它就成为了1961年ALGOL-60的前身。1966年，SIMULA又成了“更好的旧事物”，如果把它看作是一种“几乎全新的事物”，它就成为了1972年Smalltalk的前身。

一切似乎都在印证这个“理论”：1978年，Eurisko作为“更好的旧事物”出现，它“几乎算得上是新事物”。但1983年——以及整个80年代——过去了，却没有出现所谓的“新事物”。当然，这种理论本身就很荒谬——然而，我认为个人电脑的巨大商业化扼杀了过去在大学和研究实验室里进行的大量研究，因为它把有才华的年轻人吸引到了实际应用领域。由于企业极度规避风险，不愿自行开发硬件，而硬件公司又对软件缺乏真正的理解，最终的结果在大多数方面都是一次巨大的倒退。

二十世纪的一个问题是，技术变得太“容易”了。过去，无论做*任何事*，无论好坏，都需要花费足够的时间，因此结果通常都是好的。现在，我们几乎可以轻而易举地完成各种事情，尤其是在软件领域，但大多数设计也同样平庸。这是一种反向的破坏：仅仅因为能做到就去做。再加上消费者的审美水平更低，就催生了一个类似于青少年剥削市场的剥削性市场。应对之策是，以整个人类艺术史为标准和目标，对自己的设计产生极大的不满。关键在于将这种不满与自我价值感脱钩——否则，要么会让人过于沮丧，要么会因为结果平庸而过早止步。

![戴夫·罗布森](image/smalltalk/daverobson.jpg)

我将以1981年Smalltalk早期发展的故事作为结尾。当时， 《Byte》杂志发表了一系列关于Smalltalk-80的文章[Byte 1981]，随后Adele和Dave Robson合著了相关书籍[Goldberg 1983]，Smalltalk系统也在1983年正式发布。如今，程序员们可以轻松地实现虚拟机，而无需重新发明轮子；在某些情况下，一些团队甚至能够创建自己的基本类*镜像*。尽管Smalltalk几乎只能在过时的硬件架构上运行，但它仍然取得了惊人的发展（部分原因在于这些机器上进行了大量的优化工作）[Deutsch 83]。据我所知，它至今仍然是使用最广泛的面向对象系统。令我难以置信的是，此后竟然没有人提出过在质量上更胜一筹、同样简洁、优雅、易于编程、实用且全面的方案。 （可惜当时我们不知道 PROLOG，反之亦然，后来这两种语言的结合非常引人入胜。）

在理所当然地赞扬 Dan、Adele 和其他为 Smalltalk 做出贡献的人的同时，我们也不禁要问：那些 80 年代和 90 年代的 Dan 和 Adele 在哪里？他们能否带领我们进入下一个阶段？