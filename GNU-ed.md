# GNU ed 行编辑器
本手册适用于 GNU ed（版本 1.22.2，2025 年 8 月 18 日）。

[TOC]

## 1 概述
GNU ed 是一款面向行的文本编辑器。它用于创建、显示、修改和其他操作文本文件，既可以通过交互方式，也可以通过 Shell 脚本进行操作。ed 的限制版本 red 只能编辑当前目录中的文件，并且无法执行 Shell 命令。Ed 是“标准”文本编辑器，因为它是 Unix 的原始编辑器，因此被广泛使用。然而，在大多数情况下，它已被全屏编辑器取代。

GNU ed 基于 Brian W. Kernighan 和 P. J. Plauger 合著的《Pascal软件工具》（Addison-Wesley，1981 年）一书中描述的编辑器算法。

如果使用 file 参数调用，则会将 file 的副本读入编辑器的缓冲区。修改将针对此副本进行，而不是直接针对 file 本身。退出 ed 后，任何未使用“w”命令明确保存的更改都将丢失。在交互模式下，会报告文件不存在，但不会改变退出状态。

编辑有两种不同的模式：命令模式和输入模式。首次调用 ed 时，它处于命令模式。在此模式下，命令从标准输入读取并执行，以操作编辑器缓冲区的内容。一个典型的命令可能如下所示：	

```
,s/old/new/g
```

它将所有出现的字符串 old 替换为 new。

当输入命令（例如“a”（追加）、“i”（插入）或“c”（更改））时，ed 进入输入模式。这是向文件添加文本的主要方式。在此模式下，没有可用的命令；而是将标准输入直接写入编辑器缓冲区。一行由最多包含一个换行符的文本组成。在一行上输入一个句点（“.”）即可终止输入模式。

对缓冲区所做的任何更改都会设置修改标志，即使该更改不会导致缓冲区内容发生变化；例如“s/a/a/”。读取空文件（“r file”）或在命令对缓冲区进行任何更改之前终止命令（“a<newline>.<newline>”）不会更改缓冲区，因此不会设置修改标志。

所有 ed 命令均对整行或行范围进行操作；例如，“d”命令删除行；“m”命令移动行，等等。也可以通过替换操作仅修改行的一部分，如上例所示。但即使如此，“s”命令也是一次作用于整行。

通常，ed 命令由零个或多个行地址组成，后跟一个单字符命令以及可能的附加参数；即，命令的结构如下：

```
[address[,address]]command[parameters]
```

地址表示该命令将影响的行或行范围。如果指定的地址少于命令接受的地址，则使用默认地址。


## 2 行编辑简介
ed 是由 Ken Thompson 和 Dennis Ritchie 与 Unix 操作系统一起创建的。它是对其更复杂、可编程的前身 QED 的改进，Thompson 和 Ritchie 已经为其添加了模式匹配功能（参见正则表达式）。

出于本教程的目的，建议读者具备 Unix shell sh 和 Unix 文件系统的应用知识，因为 ed 旨在与它们紧密交互。（有关 bash 的详细信息，请参阅 bash 手册）。

行编辑器和显示编辑器的主要区别在于，显示编辑器可以立即反馈用户命令，而行编辑器有时需要长时间输入才能看到任何效果。当然，即时反馈的优势在于，如果犯了错误，可以立即纠正，避免造成更大的损失。在 ed 中编辑需要更多的策略和深思熟虑；但如果你能够胜任这项任务，它可以非常高效。

ed 的大部分命令语法与其他 Unix 实用程序共享。

与 Shell 一样，<RETURN>（回车键）输入一行输入。因此，当我们在 ed 中“输入”命令或文本时，每行末尾都隐含着 <RETURN> 键。在输入 <RETURN> 之前，可以通过输入 <BACKSPACE> 键（向后删除字符）或 <CONTROL>-u 键（即按住 CONTROL 键并输入 u 键）来修改行内容。

ed 首次打开时，它会提示用户执行操作，但不会像 Shell 那样提示用户。因此，让我们首先使用 <P>（提示符）命令告诉 ed 执行此操作：

```bash
$ ed
P
*
```

默认情况下，ed 使用星号（“*”）作为命令提示符，以避免与 Shell 命令提示符（“$”）混淆。

我们可以通过在 ed 内部添加 <!>（感叹号，又称“bang”）前缀来运行 Unix Shell (sh) 命令。例如：

```bash
*!date
Mon Jun 26 10:08:41 PDT 2006
!
*!for s in hello world; do echo $s; done
hello
world
!
*
```

到目前为止，这与在 Unix shell 中运行命令没有什么不同。但假设我们想要编辑命令的输出，或者将其保存到文件中。首先，我们必须将命令输出捕获到一个称为缓冲区的临时位置，以便 ed 可以访问它。这可以通过 ed 的 <r> 命令（助记符：read）来完成：

```bash
*r !cal -m
137
*
```

这里 ed 告诉我们它刚刚将 137 个字符读入编辑器缓冲区 - 即 cal 命令的输出，该命令打印一个简单的 ASCII 日历。要显示缓冲区内容，我们输入 <p>（打印）命令（不要与 prompt 命令混淆，它是大写的！）。为了指示缓冲区中应打印的行范围，我们在命令前加上 <,>（逗号），这是“整个缓冲区”的简写：

```bash
*,p
	June 2006
Mo Tu We Th Fr Sa Su
         1  2  3  4
5  6  7  8  9  10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30

*
```

现在，我们使用 <w>（写入）命令将缓冲区内容写入名为“junk”的文件：

```bash
*w junk
137
*
```

需要说明的是，经常写入缓冲区内容是一种很好的做法，因为退出 ed 后，未写入的更改将会丢失。

以下示例会话演示了使用 ed 进行行编辑的一些基本概念。我们首先在莎士比亚的帮助下创建一个名为 sonnet 的文件。与 shell 一样，所有输入到 ed 的命令后面都必须跟一个 <newline> 字符。以“#”开头的命令将被视为注释并被忽略。输入模式中以“#”开头的行只是额外的输入。

```bash
$ ed
# “a” 命令用于将文本附加到编辑器缓冲区。
a
不要再为你所做的事感到悲伤。
玫瑰有刺，会沾染泥土。
云和日食会玷污月亮和太阳，
令人作呕的溃疡会滋生在最甜美的花蕾中。
.
# 在一行中输入一个句号将使 ed 返回命令模式。
# 现在将缓冲区的内容写入文件 sonnet 并退出：
w sonnet
183
# ed 报告已写入的字符数。
q
$ ls -l
total 2
-rw-rw-r-- 1 alm 183 Nov 10 01:16 sonnet
$
```
在下一个示例中，将更正文件 sonnet 中的一些拼写错误。

```bash
$ ed sonnet
183
# 首先使用“p”命令将缓冲区的内容打印到终端。
# “,” 表示“所有行”。
,p
不要再为你所做的事感到悲伤。
玫瑰有刺，而银子会沾染泥土。
云和日食会玷污月亮和太阳，
而令人厌恶的溃疡病会滋生在最甜美的花蕾中。
# 选择第 2 行进行编辑。
2
玫瑰有刺，而银子会沾染泥土。
# 使用替换命令“s”将“银子”替换为“银泉”，
# 并打印结果。
s/filvers/silver/p
玫瑰有刺，银泉有泥。
# 并更正“fountains”的拼写。
s/utia/untai/p
玫瑰有刺，银泉有泥。
w sonnet
183
q
$
```

由于 ed 是面向行的，我们必须告诉它我们要编辑哪一行或哪一段行。在上面的例子中，我们通过指定行号或缓冲区中的顺序来实现这一点。或者，我们可以在行中指定一个唯一的字符串，例如“/filvers/”，其中“/”分隔相关字符串。后续命令仅影响选定的行，即当前行。然后，该行的部分内容将被替换命令替换，其语法为“s/old/new/”。

虽然 ed 每行只接受一个命令，但打印命令“p”是个例外，它可以附加到大多数命令的末尾。

在下一个示例中，我们将为十四行诗添加标题。

```bash
$ ed sonnet
183
a
sonnet #50
.
,p
别再为你所做的事感到悲伤。
玫瑰有刺，银色的喷泉沾满泥土。
乌云和日食玷污了月亮和太阳，
最甜美的花蕾里也藏着令人作呕的溃疡。
Sonnet #50
# 标题被附加到了末尾；我们应该使用“0a”
# 将其附加到“第一行之前”。
# 移动标题到其正确位置。
5m0p
Sonnet #50
# 标题现在是第一行，当前地址也已
# 设置为此行的地址。
,p
Sonnet #50
不要再为你所做的事感到悲伤。
玫瑰有刺，银色的喷泉沾满泥土。
乌云和日食玷污了月亮和太阳，
令人厌恶的溃疡病也生活在最甜蜜的花蕾中。
wq sonnet
195
$
```

当 ed 打开文件时，当前地址最初设置为该文件最后一行的地址。同样，移动命令 'm' 将当前地址设置为移动的最后一行的地址。

相关程序或例程包括 vi(1)、sed(1)、regex(3)、sh(1)。相关文档如下：

```
Unix 用户手册补充文档：12 -- 13
B. W. Kernighan 和 P. J. Plauger：“Pascal软件工具”，Addison-Wesley，1981 年。
```

## 3 调用 ed
运行 ed 的格式为：

```bash
ed [选项] [[+行] 文件]
red [选项] [[+行] 文件]
ed [选项] [[+行] '!命令 [参数]']
```

file 指定要读取的文件的名称。如果 file 以感叹号 (!) 开头，则将其解释为 Shell 命令。在这种情况下，读取的是通过 sh 执行的 file 的标准输出。要读取名称以感叹号（或连字符）开头的文件，请在名称前添加 ./。仅当文件名不带感叹号前缀时，才会将默认文件名设置为 file。

文件名前可以添加“+line”命令，将当前行设置为指定的行号。如果 line 超出文件的行数，则当前行设置为最后一行。

文件名前可以添加“+/re”命令，将当前行设置为与正则表达式 re 匹配的第一行；或者添加“+?re”命令，将当前行设置为与 re 匹配的最后一行。如果 re 未匹配任何行，则 ed 将立即失败，退出状态为 1，除非指定了选项 -l 且标准输入不是正则文件。

ed 支持以下选项：请参阅参数语法。

```bash
-h
--help
	打印描述选项的帮助信息并退出。
-V
--version
	在标准输出上打印 ed 的版本号并退出。所有错误报告都应包含此版本号。
-E
--extended-regexp
	使用扩展正则表达式代替 POSIX 强制使用的基本正则表达式。
-G
--traditional
	强制向后兼容。这会影响 ed 命令“G”、“V”、“f”、“l”、“m”、“t”和“!!”的行为。如果您对这些命令的默认行为不熟悉，请尝试使用此开关调用 ed。
-l
--loose-exit-status
	如果命令发生“失败”（例如，替换命令找不到任何可替换的内容），则不会以错误状态退出。当 ed 作为 crontab 的编辑器调用时，此选项非常有用。
-p string
--prompt=string
	指定命令提示符字符串并打开提示。可以使用“P”命令打开或关闭显示提示符字符串。
-q
--quiet
--silent
	抑制将诊断信息写入标准错误输出。
-r
--restricted
	以受限模式运行。此模式禁用当前目录以外的文件编辑和 shell 命令的执行。
-s
--script
	抑制“e”、“E”、“r”、“w”和“!”命令打印字节数，以及“!”命令后的“!”提示符。同时抑制“插入换行符”和“附加换行符”消息。此选项不会抑制将诊断信息写入标准错误输出（参见上文的 -q 选项）。如果 ed 的标准输入来自脚本，-s 选项可能会有用。
-v
--verbose
	打开帮助模式；打印一条帮助信息，解释每个“?”通知的原因。可以使用“H”命令切换此模式。使用此选项有助于调试 ed 脚本。
--strip-trailing-cr
	删除 DOS 文件中文本行末尾的回车符。CR 仅会从行尾的 CR/LF（回车/换行）对中删除。行中其他位置的 CR，包括结束未结束行的 CR，不会被删除。将缓冲区保存到文件时，这些 CR 不会被恢复。
--unsafe-names
	ed 拒绝包含控制字符的文件名，除非此选项允许。即使指定了此选项，文件名中的换行符也会被拒绝。
```

退出状态：0 表示正常退出，1 表示环境问题（无效的命令行选项、内存耗尽、命令失败等），2 表示输入文件存在问题（文件未找到、缓冲区被修改、I/O 错误），3 表示内部一致性错误（例如，bug）导致 ed 崩溃。

## 4 命令行参数的语法
POSIX 建议命令行参数遵循以下约定。

+ 如果命令行参数以连字符 ('-') 开头，则该参数为选项。
+ 选项名称由单个字母数字字符组成。
+ 某些选项需要参数。
+ 选项及其参数可以作为单独的标记出现，也可以不作为单独的标记出现。（换句话说，分隔它们的空格是可选的）。因此，-o foo和 -ofoo 是等效的。
+ 在单个标记中，一个或多个不带参数的选项，后跟最多一个带参数的选项，可以跟在连字符后面。因此，-abc 等同于 -a -b -c。
  选项通常位于其他非选项参数之前。
+ 参数“--”终止所有选项；任何后续参数都被视为非选项参数，即使它们以连字符开头。
+ 由单个连字符组成的标记被解释为普通的非选项参数。按照惯例，它用于指定标准输入、标准输出或名为“-”的文件。

GNU 在这些约定的基础上添加了长选项：

+ 长选项由两个连字符（“--”）后跟一个由字母数字字符和连字符组成的名称组成。选项名称通常为一到三个单词长，用连字符分隔单词。长选项名称可以使用缩写，只要缩写是唯一的即可。
+ 长选项及其参数可以作为单独的标记出现，也可以不出现。如果是后者，则必须用等号“=”分隔。因此，--foo bar 和 --foo=bar 等效。
  
## 5 行寻址
地址表示缓冲区中的行号。ed 维护一个当前地址，该地址通常在未指定任何地址时作为默认地址提供给命令。首次读取文件时，当前地址设置为文件最后一行的地址。通常，当前地址设置为受命令影响的最后一行的地址。

地址表示行号的规则有一个例外，即地址“0”（零）。这表示“缓冲区的开头”，并且在任何有意义的地方都有效。

地址范围是由逗号（“,”）或分号（“;”）分隔的两个地址组成的。范围中第一个地址的值不能超过第二个地址的值。

在以分号分隔的范围内，当前地址（“.”）在计算第二个地址之前设置为第一个地址。如果第二个地址包含正则表达式，则可以使用此功能设置搜索的起始行。地址“0”（零）作为起始点是有效的，因此“0;/re/”可以匹配缓冲区第一行中的“re”。

逗号或分号分隔符两侧的地址可以省略。如果范围内仅给出了第一个地址，则第二个地址将设置为给定的地址。如果仅给出了第二个地址，则生成的地址对分别为“1,addr”和“.;addr”。如果给出了一个 n 元组的地址，其中 n > 2，则相应的范围由 n 元组中的最后两个地址确定。如果只需要一个地址，则使用最后一个地址。向需要零个地址的命令提供任意数量的地址都是错误的。

行地址的构造如下：
```bash
.
	缓冲区中的当前行（地址）。
$
	缓冲区中的最后一行。
n
	缓冲区中的第 n 行，其中 n 是范围在“0,$”之间的数字。
+n
	下n行，其中 n 是非负数。
-n
	上n行，其中 n 是非负数。
+
	下一行。相当于“+1”，可以重复执行，且效果累加。
-
	上一行。相当于“-1”，可以重复执行，且效果累加。
,
	缓冲区中的第一行到最后一行。相当于地址范围“1,$”。
;
	缓冲区中当前行到最后一行。相当于地址范围“.;$”。
/re/[I]
	包含正则表达式 re 的下一行。搜索会绕回到缓冲区的开头，并在必要时继续向下搜索到当前行。后缀“I”是 GNU 扩展，它使 ed 以不区分大小写的方式匹配 re。
?re?[I]
	包含正则表达式 re 的上一行。搜索会绕回到缓冲区的末尾，并在必要时继续向下搜索到当前行。后缀“I”是 GNU 扩展，它使 ed 以不区分大小写的方式匹配 re。
'x
	撇号 x 字符对指向先前由“k”（标记）命令标记的行，其中“x”是可移植字符集“[a-z]”中的小写字母。
```
地址后可以跟一个或多个地址偏移量，可选地用空格分隔。偏移量的构造如下：

+ “+”或“-”后跟一个数字，用于在地址中添加或减去指定的行数。
+ '+' 或 '-' 后面不带数字，会在地址上加 1 或减 1。
+ 数字会将指定的行数添加到地址中。

如果中间地址值为负数或大于缓冲区最后一行的地址，则不会出错。如果最终地址值为负数或大于缓冲区最后一行的地址，则会出错。如果使用正则表达式搜索未找到匹配的行，则会出错。

## 6 正则表达式
正则表达式是用于选择文本的模式。例如，ed 命令
```bash
g/string/
```
打印所有包含 string 的行。's' 命令也使用正则表达式来选择要替换为新文本的旧文本。

除了指定字符串字面量之外，正则表达式还可以表示多种类型的字符串。这样表示的字符串被称为与相应的正则表达式匹配。如果正则表达式可以匹配一行中的多个字符串，则选择最左边的匹配项。如果正则表达式允许匹配的字符数可变，则匹配从该点开始的最长序列。

空正则表达式等同于最后一个处理的正则表达式。因此，'/re/s//replacement/' 会将 re 替换为 replacement。

作为 GNU 扩展，正则表达式 /re/ 后面可以跟后缀 'I'，这使得 ed 以不区分大小写的方式匹配 re。请注意，后缀会在编译正则表达式时进行评估，因此将其与空正则表达式同时指定是无效的。

使用 POSIX 基本正则表达式语法构建正则表达式时，会使用以下符号：

```bash
c
	任何未在下方列出的字符 c，包括“{”、“}”、“(”、“)”、“<”和“>”，均匹配自身。
\c
	任何反斜杠转义的字符 c，除“{”、“}”、“(”、“)”、“<”、“>”、“b”、“B”、“w”、“W”、“+”和“?”外，均匹配自身。
.
	匹配任意单个字符。
[char-class]
	匹配 char-class 中的任意单个字符。要包含 char-class 中的“]”，它必须是第一个字符。可以通过用“-”分隔范围的末尾字符来指定字符范围，例如，“a-z”指定小写字符。以下字面表达式也可用于 char-class 中，以指定字符集：
		[:alnum:] [:cntrl:] [:lower:] [:space:]
		[:alpha:] [:digit:] [:print:] [:upper:]
		[:blank:] [:graph:] [:punct:] [:xdigit:]
	如果 '-' 作为 char-class 的第一个或最后一个字符出现，则它匹配自身。char-class 中的所有其他字符匹配自身。

char-class 中以下形式的模式：

		[.col-elm.]
		[=col-elm=]
其中 col-elm 是排序元素，根据 'locale'(5) 进行解释。有关这些结构的说明，请参阅 'regex'(7)。

[^char-class]
	匹配除换行符之外的任何单个字符，且不属于 char-class。char-class 的定义如上所述。
^
	如果“^”是正则表达式的第一个字符，则将正则表达式锚定到行首。否则，它匹配自身。
$
	如果“$”是正则表达式的最后一个字符，则将正则表达式锚定到行尾。否则，它匹配自身。
\(re\)
	定义一个（可能为空的）子表达式 re。子表达式可以嵌套。后续的反向引用形式为“\n”，其中 n 是 [1,9] 范围内的数字，将扩展为第 n 个子表达式匹配的文本。例如，正则表达式“\(a.c\)\1”匹配字符串“abcabc”，但不匹配“abcadc”。子表达式的排序相对于其左分隔符。
*
	匹配紧接在其之前的正则表达式的零次或多次重复。正则表达式可以是单字符正则表达式，也可以是子表达式。如果“*”是正则表达式或子表达式的第一个字符，则它匹配自身。“*”运算符有时会产生意外的结果。例如，正则表达式“b*”匹配字符串“abbb”的开头，而不是子字符串“bbb”，因为空字符串是唯一最左边的匹配项。
\{n,m\}
\{n,\}
\{n\}
	匹配紧接在其前的单字符正则表达式或子表达式至少 n 次，最多 m 次。如果省略 m，则匹配至少 n 次。如果也省略逗号，则匹配恰好 n 次。如果上述任何一种形式首先出现在正则表达式或子表达式中，则按字面意思解释（例如，正则表达式“\{2\}”匹配字符串“{2}”，依此类推）。

以下基本正则表达式运算符的扩展前面带有反斜杠“\”，以区别于传统的 ed 语法。根据您系统中特定的正则表达式实现，这些扩展可能不可用。

\<
\>
	将紧随其后的单字符正则表达式或子表达式锚定到单词的开头（如果是“\<”）或结尾（如果是“\>”），即 ASCII 码中最长的字母数字字符串，包含下划线 (_)。
\`
\'
	无条件匹配一行的开头“\`”或结尾“\”。
\?
	可选匹配紧随其后的单字符正则表达式或子表达式。例如，正则表达式“a[bd]\?c”匹配字符串“abc”、“adc”和“ac”。如果“\?”出现在正则表达式或子表达式的开头，则匹配文字“?”。
\+
	匹配紧接在其之前的单字符正则表达式或子表达式出现更多次。因此，正则表达式 'a\+' 是 'aa*' 的简写。如果 '\+' 出现在正则表达式或子表达式的开头，则它匹配文字 '+'。
\b
	匹配单词的开头或结尾（空字符串）。因此，正则表达式 '\bhello\b' 等同于 '\<hello\>'。但是，'\b\b' 是有效的正则表达式，而 '\<\>' 则不是。
\B
	匹配单词内部的（空字符串）。
\w
	匹配任何单词组成字符（字母、数字和下划线）。
\W
	匹配任何非单词组成字符。
```
## 7 命令
所有 ed 命令都是单个字符，但有些命令需要额外的参数。如果命令的参数跨越多行，则除最后一行外，每行都必须以反斜杠 ('\') 结尾。

通常，每行最多允许一个命令。但是，大多数命令都接受打印后缀，可以是“p”（打印）、“l”（列表）或“n”（枚举）中的任意一个，用于打印受该命令影响的最后一行。提供多个打印后缀不可移植，但 ed 允许任意不重复的打印后缀组合并组合其效果。如果指定了任何后缀字母，则必须紧跟在命令之后。

“e”、“E”、“f”、“r”和“w”命令接受可选的文件参数，该参数与命令字母之间用一个或多个空格分隔。

中断（通常为 <Control-C>）的作用是中止当前命令并将编辑器返回到命令模式。

ed 可识别以下命令。如果未指定（括号中），则命令会与提供的默认地址或地址范围一起显示。

```bash
(.)a
	将文本追加到缓冲区中指定行之后。地址“0”（零）对此命令有效；它将输入的文本放在缓冲区的开头。文本在输入模式下输入。当前地址设置为输入的最后一行的地址，如果没有指定行，则设置为指定行。
(.,.)c
	更改缓冲区中的行。指定行将从缓冲区中删除，并在其位置插入文本。文本在输入模式下输入。当前地址设置为输入的最后一行的地址，如果没有指定行，则设置为删除的最后一行之后的新行地址；如果删除的行最初位于缓冲区末尾，则当前地址设置为新的最后一行的地址；如果缓冲区中没有剩余行，则当前地址设置为零。删除的行将复制到剪切缓冲区。
(.,.)d
	从缓冲区中删除指定行。当前地址设置为删除的最后一行之后的新地址；如果删除的行最初位于缓冲区末尾，则当前地址设置为新的最后一行的地址；如果缓冲区中没有剩余行，则当前地址设置为零。删除的行将复制到剪切缓冲区。
e file
	编辑 file，并设置默认文件名。如果未指定 file，则使用默认文件名。在读取新文件之前，将删除缓冲区中的所有行。如果 file 不存在，则会打印警告而不是字节数，并且生成的缓冲区将保留为空。当前地址设置为缓冲区最后一行的地址。
	如果 file 以感叹号 (!) 为前缀，则将其解释为要读取其输出的 Shell 命令（请参阅下面的 Shell 转义命令“!”）。在这种情况下，默认文件名保持不变。要编辑名称以感叹号开头的文件，请在名称前添加 ./。
	如果设置了缓冲区修改标志，则会打印警告。如果在中间没有错误或修改缓冲区的命令的情况下，又执行了另一个“e”或“q”命令，则会在不发出警告的情况下执行该命令，并且对缓冲区的任何更改都会丢失。

E file
	无条件编辑 file。这与“e”命令类似，不同之处在于未写入的更改会被丢弃且不发出警告。
f file
	将默认文件名设置为 file，无论 file 是否指向现有文件。如果未指定 file，则会打印默认文件名。对 file 执行波浪号扩展；如果 file 以 ~/ 开头，则 ~ 会扩展为指定您的主目录 $HOME。

(1,$)g/re/[I]command-list
	全局命令。全局命令对文件进行两次遍历。第一次遍历时，所有与正则表达式 re 匹配的行都会被标记。后缀“I”是 GNU 扩展，它使 ed 以不区分大小写的方式匹配 re。然后，按顺序从文件开头到文件结尾，对每个标记的行执行给定的命令列表，并将当前地址设置为该行的地址。任何被命令列表修改的行都将被取消标记。当前地址的最终值是上次执行的命令列表中最后一个命令所赋的值。如果没有匹配的行，则当前地址保持不变。命令列表的执行在出现第一个错误时停止。
命令列表的第一个命令必须出现在与“g”命令在同一行。命令列表中的其他命令必须单独成行。多行命令列表中，除最后一行外，所有行都必须以反斜杠 ('\') 结尾。除“g”、“G”、“v”和“V”外，其他命令均可使用。用于终止“a”、“c”和“i”命令输入模式的“.”如果是命令列表的最后一行，则可以省略。默认情况下，命令列表中的换行符相当于“p”命令。如果使用命令行选项 -G 调用 ed，则命令列表中的换行符相当于“.+1p”命令。

(1,$)G/re/[I]
	交互式全局命令。以交互方式编辑与正则表达式 re 匹配的行。后缀“I”是 GNU 扩展，使 ed 以不区分大小写的方式匹配 re。对于每个匹配的行，都会打印该行，设置当前地址，并提示用户输入命令列表。当前地址的最终值是上一个执行的命令所赋的值。如果没有匹配的行，则当前地址保持不变。
	命令列表的格式与“g”命令相同。单独的换行符表示一个空的命令列表。单个“&”表示重复最后一个非空的命令列表。

h
	打印一条帮助消息，解释最近一次“?”通知的原因。
H
	切换帮助消息的打印（参见上面的“h”命令）。如果帮助模式已打开，还会打印与最近一次“?”通知对应的帮助消息。默认情况下，不打印帮助消息。
(.)i
	在缓冲区中指定行之前插入文本。地址“0”（零）对此命令有效；它将输入的文本放在缓冲区的开头。文本在输入模式下输入。当前地址设置为输入的最后一行的地址，如果没有行，则设置为指定行。
(.,.+1)j
	连接指定行，用包含连接文本的单行替换它们。如果只指定一个地址，此命令不执行任何操作。如果行已连接，则被替换的行将被复制到剪切缓冲区，并将当前地址设置为连接行的地址。否则，当前地址保持不变。
(.)kx
	用小写字母“x”标记一行。在后续命令中，该行可以表示为“x”（即单引号后跟“x”）。除非删除或修改该行，否则标记不会被清除。当前地址保持不变。
(.,.)l
	列表命令。明确打印指定行。每行的末尾都用“$”标记，文本中的每个“$”字符前面都打印一个反斜杠。特殊字符将打印为转义序列。当前地址设置为打印的最后一行的地址。
(.,.)m(.)
	移动缓冲区中的行。指定行移动到右侧目标地址之后。目标地址“0”（零）对此命令有效；它将指定行移动到缓冲区的开头。如果目标地址在要移动的行范围内，则会出错。当前地址设置为移动的最后一行的新地址。
(.,.)n
	数字命令。打印指定行，并在每行前面加上行号和一个制表符。当前地址设置为打印的最后一行的地址。
(.,.)p
	打印指定行。当前地址设置为打印的最后一行的地址。
P
	打开和关闭命令提示符。除非使用命令行选项 -p 指定提示字符串，否则命令提示符默认关闭。默认提示字符串为星号 ('*')。
q
	退出 ed 命令。如果设置了缓冲区修改标志，则会打印一条警告。如果在中间没有错误或修改缓冲区的命令的情况下发出另一个“e”或“q”命令，则会在不发出警告的情况下执行该命令，并且对缓冲区的任何更改都将丢失。
Q
	无条件退出 ed 命令。这与“q”命令类似，不同之处在于未写入的更改会被丢弃且不发出警告。
($)r file
	读取 file 并将其附加到指定行之后。如果未指定 file，则使用默认文件名。如果命令之前没有默认文件名，则将默认文件名设置为 file。否则，默认文件名保持不变。地址“0”（零）对此命令有效；它从缓冲区的开头读取文件。当前地址设置为上次读取行的地址，如果没有指定行，则设置为指定行。
	如果文件以感叹号 (!) 开头，则该文件将被解释为一个要读取输出的 Shell 命令（参见下文的 Shell 转义命令“!”）。在这种情况下，默认文件名保持不变。要读取以感叹号开头的文件，请在文件名前添加 ./。

(.,.)t(.)
	将指定地址的行复制（即传输）到右侧目标地址之后。如果目标地址为“0”（零），则行将从缓冲区的开头复制。当前地址设置为最后复制行的地址。
u
	撤消 e撤销上一个修改缓冲区内容的命令，并将当前地址恢复到执行命令之前的状态。全局命令“g”、“G”、“v”和“V”在撤销操作中被视为单个命令。“u”是其逆操作；它只能撤销上一个命令。

(1,$)v/re/[I]command-list
	这与“g”命令类似，不同之处在于它将命令列表应用于与正则表达式 re 不匹配的每个寻址行。
(1,$)V/re/[I]
	这与“G”命令类似，不同之处在于它以交互方式编辑与正则表达式 re 不匹配的寻址行。
(1,$)w file
	将寻址行写入 file。file 中任何先前的内容都将丢失，且不会发出警告。如果没有默认文件名，则将默认文件名设置为 file，否则保持不变。如果未指定文件名，则使用默认文件名。如果写入了整个缓冲区，则清除缓冲区修改标志。当前地址保持不变。
如果文件以感叹号 (!) 开头，则该文件将被解释为 Shell 命令，并将指定行写入其标准输入（请参阅下文的 Shell 转义命令“!”）。在这种情况下，默认文件名保持不变。将缓冲区写入 Shell 命令不会清除缓冲区修改标志。要写入名称以感叹号开头的文件，请在文件名前添加 ./。

(1,$)wq file
	将指定行写入 file，然后执行“q”命令。
(1,$)W file
	将指定行附加到 file 末尾。这与“w”命令类似，不同之处在于不会破坏 file 先前的内容。当前地址保持不变。
(.)x
	将剪切缓冲区的内容复制（放置）到指定行之后。当前地址设置为复制的最后一行的地址。
(.,.)y
	将指定行复制（复制）到剪切缓冲区。剪切缓冲区将被后续的“c”、“d”、“j”、“s”或“y”命令覆盖。当前地址保持不变。
(.+1)zn
	滚动。从指定行开始一次打印 n 行，并将窗口大小设置为 n。如果未指定 n，则使用当前窗口大小。窗口大小默认为屏幕大小减两行，如果无法确定屏幕大小，则为 22。环境变量 LINES 可用于设置初始窗口大小。LINES 和 n 不受屏幕大小限制。当前地址设置为最后打印行的地址。

!command
[2addr]!command
	Shell 转义命令。通过 sh 执行命令。如果命令的第一个字符是“!”，则将其替换为前一个“!command”的文本。因此，“!!”重复上一个“!command”。ed 不会处理 command 中的反斜杠 ('\') 转义字符。但是，每个未转义的“%”都会被替换为默认文件名，并且每个转义的“%”中的反斜杠都会被删除。当 shell 从执行返回时，会在标准输出中打印一个“!”。当前地址保持不变。
	如果指定了一个或多个地址，则指定地址的行将写入 command 的标准输入，然后替换为从 command 的标准输出和标准错误中读取的行。将打印两个字节计数；一个表示写入 command 的字节数，另一个表示从 command 读取的字节数。当前地址设置为读取的最后一行的地址，如果没有，则设置为第一个指定地址的行之前的行。

(.,.)#
	开始注释；该行的其余部分（直到换行符）将被忽略。如果给出的行地址后跟分号，则当前地址设置为该地址。否则，当前地址保持不变。
($)=
	打印指定行的行号。当前地址保持不变。
(.+1)<newline>
	空命令。单独使用地址会打印指定行。单独使用 <newline> 相当于 '+1p'。当前地址设置为打印行的地址。
```

## 8 替换命令
替换命令 's' 使用替换功能替换指定行中与正则表达式 re 匹配的文本。默认情况下，每行仅替换第一个匹配项。's' 命令的语法为：

```bash
(.,.)s/re/replacement/[suffixes]
```

's' 命令接受以下可选后缀的任意组合：

```bash
g
	'global'：替换行中的所有匹配项，而不仅仅是第一个匹配项。
count
	正数表示仅替换第 count 个匹配项。 'g' 和 'count' 不能在同一命令中同时指定。
l
n
p
	常用的打印后缀。请参阅打印后缀。
I
i
	后缀 'I' 是 GNU 扩展，它使 ed 以不区分大小写的方式匹配 re。
```

如果任何寻址行均未执行替换，则会出错。当前地址设置为发生替换的最后一行的地址。如果拆分了一行，则认为每个新行都发生了替换。如果没有执行替换，则当前地址保持不变。最后修改的行将复制到剪切缓冲区。

*re* 和 *replacement* 可以用除 <space>、<newline> 之外的任何字符分隔。以及如下所示的 's' 命令形式所使用的字符。如果省略最后一个分隔符，则打印受影响的最后一行，如同指定了打印后缀 'p' 一样。如果 's' 命令是 'g' 或 'v' 命令列表的一部分，并且不是列表中的最后一个命令，则不能省略最后一个分隔符，因为后面的转义换行符的含义会变得模棱两可。

*replacement* 中未转义的 '&' 将被当前匹配的文本替换。字符序列 '\m'（其中 m 是 [1,9] 范围内的数字）将被匹配文本的第 m 个反向引用表达式替换。如果相应的反向引用表达式不匹配，则字符序列 '\m' 将被空字符串替换。如果 *replacement* 包含单个 '%'，则使用最后一个替换中的替换。

通过在替换中包含用反斜杠 ('\') 转义的换行符，可以拆分一行。替换中的每个反斜杠都会删除其后字符的特殊含义（如果有）。

ed 可以使用以下替代语法重复上一次替换：

```bash
(.,.)s[suffixes]
```

此形式的 's' 命令接受上述后缀 'g' 和 'count'，以及后缀 'p' 和 'r' 的任意组合。后缀 'g' 切换上一次替换的全局后缀，并将 count 重置为 1。后缀 'p' 切换上一次替换的打印后缀。后缀 'r' 导致使用上一次搜索的 re，而不是上一次替换的 re（如果搜索发生在替换之后）。


## 9 限制
如果终端挂起且缓冲区已被修改且不为空，ed 会尝试将缓冲区写入文件 ed.hup，如果写入失败，则写入 $HOME/ed.hup。

如果文本（非二进制）文件未以换行符结尾，则 ed 会在读取/写入时添加换行符。对于二进制文件，ed 不会在读取/写入时添加换行符。二进制文件至少包含一个 ASCII NUL 字符。如果最后一行已被修改，则在写入之前读取空文件（例如 /dev/null）会阻止在二进制文件中添加换行符。

为了跟踪缓冲区中的文本行，ed 使用一个双向链表结构，其中包含每行的位置和大小。这导致每行开销为 2 个“指针”、“长整型”和 1 个“整数”。最大行长度为 INT_MAX - 1 个字节。最大行数为 INT_MAX - 2 行。

## 10 诊断
ed 打印两种类型的消息：写入标准错误的诊断消息（错误和警告）和写入标准输出的帮助消息。可以使用选项 -q 抑制诊断消息。可以使用选项 -v 启用帮助消息，并使用命令“H”切换显示。

当命令首次修改从只读文件加载的缓冲区时，ed 会发出警告。

发生错误时，如果 ed 的标准输入是常规文件或此处文档，则退出；否则，它会打印“？”并返回命令模式。可以使用“h”（帮助）命令打印最后一个错误的解释。

如果“u”（撤消）命令出现在全局命令列表中，则该命令列表仅执行一次。


## 11 报告错误
ed 中可能存在错误。本手册中肯定存在错误和遗漏。如果您报告这些错误，它们将被修复。如果您不报告，则没有人会知道，并且它们将永远无法修复，甚至更长时间。

如果您发现 ed 中的错误，请发送电子邮件至 bug-ed@gnu.org。请提供版本号，您可以通过运行“ed --version”来查看版本号。

## 12 GNU 自由文档许可证
(略)